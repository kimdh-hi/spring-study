sql-tuning-ch2

## SQL 튜닝 용어를 직관적으로 이해하기 

<br>

### 물리 엔진과 오브젝트 용어 
- DBMS를 구성하는 엔진, 내부 프로세스, 데이터를 저장하는 오브젝트 등의 용어

#### DB 엔진 용어
DBMS가 요청받은 SQL을 처리하는 과정 
1. SQL 문을 실행한다. 
2. DB엔진은 실행된 SQL문에 문법에러가 있는지, SQL실행 대상이 현재 DB에 존재하는 테이블 인지 등 세부사항을 검사한다. => Parser의 역할
3. 요청한 데이터를 빠르게 찾기 위한 전략적 계획을 수립한다. => Optimizer의 역할
4. 수립된 계획에 따라 스토리지에 위친한 데이터를 찾고, 찾은 결과를 MySQL 엔진에 전달한다.
5. MySQL 엔진은 전달받은 데이터를 필터링하고 필요한 연산을 수행하여 사용자에게 반환한다.

#### 스토리지 엔진
- `InnoDB`, `MyISAM`, `Memory` ...
- 요청된 SQL을 토대로 디스크나 메모리에서 필요한 데이터를 가져오는 역할을 수행한다.
  가져온 데이터는 다시 MySQL 엔진으로 전달한다.
- 각 스토리지 엔진의 저장방식이 다를 수 있고 상황에 따라 스토리지 엔진을 선택하여 사용할 수 있다.
- `InnoDB`: 온라인 상의 트랜잭션을 처리하는 OLTP 환경에서 사용되는 스토리지 엔진
- `MyISAM`: 대량의 쓰기 트랜잭션이 발생되는 경우 사용되는 스토리지 엔진
- `Memory`: 읽기 성능에서 효과를 내기 위한 스토리지 엔진

#### MySQL 엔진
- 사용자로부터 넘겨받은 SQL에 대한 문법 검사 및 세부사항 검사 
- SQL을 최소단위로 분리해서 빠르게 데이터를 찾을 수 있는 경로를 모색 => 옵티마이저 (실행계획 수립)
- 스토리지 엔진으로부터 받아온 데이터를 대상으로 필터링을 수행하고 필요한 연산을 수행

```
SQL 처리를 택시에 비유
첫번째 손님: 아랍어로 목적지를 말함
  - 아랍어를 알아들을 수 없으므로 운행 불가
두번째 손님: "뉴욕으로 가주세요."
  - 우리나라에는 뉴욕이라는 도시가 없으므로 운행 불가  
세번째 손님: "서울 강남으로 가주세요."
  - OK
  - 목적지가 존재하므로 경로에 대한 모색 후 운행  
```

#### SQL 문 수행절차
1. 사용자가 SQL문 실행
2. 파서(Parsor)가 요청된 SQL문을 최소단위로 분리 후 전처리기에 전달
3. 전처리기는 최소단위로 분리된 구성요소로 권한 및 대상 객체 존재여부를 확인
4. 옵티마이저에 의해 실행계획이 수립되고 수립된 실행계획으로 스토리지 엔진을 호출
5. 스토리지 엔진에서 가져온 데이터를 엔진 실행기에서 필터링 및 연산 수행 후 사용자에게 결과 전달
( 파서 -> 전처리기 -> 옵티마이저 -> 엔진 실행기 )

#### 옵티마이저
- MySQL의 핵심엔진 (DBMS의 두뇌)
- 불필요한 조건 제거 및 연산과정 단순화
- 테이블 접근 순서
- 인덱스 사용 여부
```
실행계획을 수립하는 것 만으로 리소스를 점유하는 작업이다.
또한, 옵티마이저의 모든 실행계획이 최적으로 실행계획은 아닐 수 있다.
```

#### 고유 인덱스
- 인덱스를 구성하는 열의 모든 데이터가 유일하다. (중복 x)
  만약 중복이 발생한다면 고유 인덱스 중복 체크 과정에서 에러를 발생시킨다.
- 인덱스가 새로 추가되어 정렬을 수행할 때 중복체크를 수행  
```sql
학번을 PK로 하는 학생 테이블에서 연락처를 조회하는 일이 빈번한 경우
연락처를 대상으로 고유 인덱스를 생성한다.

ALTER TABLE 학생
ADD UNIQUE INDEX TEL_IDX(TEL);
```

#### 비고유 인덱스
- 데이터가 새로 입력되어 인덱스가 재정렬되더라도 중복체크를 하지 않는다.
```sql
ALTER TABLE 학생
ADD INDEX TEL_IDX(TEL);
```

#### 뷰 View
- `학생 테이블`에 (학번, 이름, 생년월일, 연락처 ...) 등의 칼럼이 있는 경우
- `학생_뷰` 라는 뷰를 생성하고 학번과 이름, 연락처만 조회되도록 생성한다.
- `학생 테이블`에서 데이터가 변경되면 `학생_뷰`에서도 변경된 데이터가 조회된다.
  반대로 `학생_뷰`에서 변경된 데이터도 `학생 테이블`에 반영된다.
- `학생 테이블`에 공개하고 싶지 않은 정보가 있다면 뷰를 통해 제한된 정보만을 제공해서 *보안적*으로 운용할 수 있다.
```sql
CREATE VIEW 학생_뷰 as
	SELECT 학번, 이름, 연락처 
	FROM 학생;
``` 
*** 

<br>

### 서브쿼리
- `SELECT` 내부에 `SELECT` 를 추가 작성한 형태이다.
- 서브쿼리 종류
  - SELECT 절 서브쿼리 (스칼라 서브쿼리)
  - FROM 절 서브쿼리 (인라인 뷰)
  - WHERE 절 서브쿼리 (중첩 서브쿼리)

#### 스칼라 서브쿼리 (SELECT 절 서브쿼리)
- 가장 바깥의 SELECT 절에 해당하는 메인쿼리 SELECT 절에 또 다른 SELECT 절이 있는 형태이다.
- 스칼라 서브쿼리의 결과는 1행 1열의 구조여야 한다. (한 개 컬럼)
- 스칼라 서브쿼리는 보통 집계함수와 함께 사용된다. (max, min, avg, sum, count ...)
```sql
SELECT 이름
	(SELECT COUNT(*)
		FROM 학생 as 학생2
		WHERE 학생2.이름 = 학생1.이름) 카운트
FROM 학생 as 학생1;	
```  

#### 인라인 뷰 (FROM 절 서브쿼리)
- 메인쿼리의 FROM 절에 위치한 SELECT 절 
- 일시적으로 View를 생성하는 방식이다.
```sql
SELECT 학생2.학번, 학생2.이름
FROM (SELECT * 
		FROM 학생
		WHERE 성별='남') 학생2;
```

#### 중첩 서브쿼리 (Where 절 서브쿼리)
- 메인쿼리의 Where 절에 위치한 SELECT 절
```sql
SELECT *
FROM 학생
WHERE 학번 = (SELECT MAX(학번)
				FROM 학생)
```

#### 비상관 서브쿼리
- 메인쿼리와 서브쿼리 간 관계성이 없는 경우에 해당
- 서브쿼리가 독립적으로 먼저 실행되고 그 결과를 메인쿼리에 결과를 던져주는 형태
```sql
SELECT *
FROM 학생
WHERE 학번 IN (SELECT 학번
				FROM 학생
				WHERE 성별 = '남');
```
- 옵티마이저에 따라서 서브쿼리가 제거되고 하나의 메인쿼리로 통합되는 뷰 병합이 발생할 수 있다.

#### 상관 서브쿼리
- 서브쿼리가 수행되기 위해 메인쿼리의 값을 필요로하는 경우에 해당
  (SELECT 절 스칼라 서브쿼리 or WHERE 절 중첩 서브쿼리)
```sql
SELECT *
FROM 학생
WHERE 학번 IN (SELECT 학번
				FROM 지도교수
				WHERE 학생.학번 = 지도교수.학번);
```  


***
<br>

### 조인 Join
- Inner Join
- Left Outer Join / Right Outer Join
- Full Outer Join (MySQL, MariaDB 지원 x)
- Cross Join
- Natural Join

#### Innter Join
- 교집합
```sql
[ 명시적 조인 ]
SELECT 학생.학번, 학생.이름, 지도교수.교수명
FROM 학생
	JOIN 지도교수
	ON 학생.학번 = 지도교수.학번;

[ 묵시적 조인 ]
SELECT 학생.학번, 학생.이름, 지도교수.교수명
FROM 학생, 지도교수
	where 학생.학번 = 지도교수.학번;
```
- 명시적 조인, 묵시적 조인 모두 같은 결과를 출력한다.

#### Left Outer Join
- 왼쪽을 기준으로 나중에 오른쪽 테이블을 조인
  - 조인 조건과 일치하지 않더라도 왼쪽 테이블의 결과에 포함된다. 
    (일치하지 않는 오른쪽 부분은 null로 채워버림)
```sql
SELECT 학생.학번, 학생.이름, 지도교수.교수명
FROM 학생
	LEFT [OUTER] JOIN 지도교수
	ON 학생.학번 = 지도교수.학번;
```  
- 조인의 방향을 반대로 바꾼 Right Outer Join도 가능하다.
- 대부분의 경우 사람은 왼쪽에서 오른쪽으로 인식하므로 Right Outer Join을 Left로 변경해서 일관성 있는 쿼리를 작성하는 것이 관리 측면에서 유리하다.

```sql
SELECT *
	FROM B_테이블
	RIGHT JOIN A_테이블 ON B_테이블.fk = A_테이블.pk;

SELECT *
	FROM A_테이블
	LEFT JOIN B_테이블 ON A_테이블.pk = B_테이블.fk;
```

#### Cross Join
- 조인에 참여하는 테이블에서 발생할 수 있는 모든 조합을 반환
- 학생[1,2,3,4] / 지도교수[1,2,4,99] => Cross Join 수행
  - 4 * 4 = 16 (총 16개 row를 반환)
```sql
[ 명시적 Cross Join ]
SELECT 학생.학번, 학생.이름, 지도교수.학번, 지도교수.교수명
	FROM 학생
	CROSS JOIN 지도교수

[ 묵시적 Cross Join ]
SELECT 학생.학번, 학생.이름, 지도교수.학번, 지도교수.교수명
	FROM 학생, 지도교수
```
- Join 없이 두 개 테이블을 From 절에 명시하면 묵시적으로 교차조인이 발생한다.

#### Natural Join
- 두 테이블의 칼럼명이 동일한 경우 Join 절을 작성하지 않아도 자동으로 조인을 수행한다.
- 조인의 결과는 내부 조인과 동일하다.
```sql
SELECT 학생.*, 지도교수.*
FROM 학생
NATURAL JOIN 지도교수;
```
- 자연조인을 실행했는데 두 테이블 간 동일한 칼럼명이 없다면 교차조인을 수행한다.
- 동일한 컬럼명이 있는 경우 => 해당 컬럼으로 내부조인 수행 
- 동일한 칼럼며이 없는 경우 => 교차조인



### Join 알고리즘
- 다수 테이블을 대상으로 Join을 수행할 때 동시에 여러 개 테이블에 접근할 수 없으므로 우선순위를 정하게 된다.
- 각 테이블에 접근하는 선후관계에 따라 `드라이빙 테이블`과 `드리븐 테이블` 로 구분된다.

#### 드라이빙 테이블, 드리븐 테이블
- 드라이빙 테이블: Join 시 두 테이블에 동시에 접근할 수 없는 경우 머저 접근되는 테이블이다.
- 드리븐 테이블: 드라이빙 테이블의 결과를 조회되는 테이블이다.
```sql
select 학생.학번, 학생.이름, 비상연락망.관계, 비상연락망.연락처
from 학생
JOIN 비상연락망
	ON 학생.학번 = 비상연락망.학번
WHERE 학생.학번 IN (1, 100);
```
- 위 쿼리는 학생 테이블과 비상연락망 테이블을 대상으로 Join을 수행한다.
- 먼저 `Where`문에 의해서 학생 테이블을 조회하고 그 결과로 비상연락망 테이블과의 Join을 수행한다.
  여기서 `드라이빙 테이블`은 학생 테이블이 되고, `드리븐 테이블`은 비상연락망 테이블이 된다.
- `드라이빙 테이블`의 결과로 `드리븐 테이블`에 접근하기 때문에 `드라이빙 테이블`을 어떤 테이블로 선정할 지는 중요한 문제이다.

#### 중첨 루프 조인 (NL Join, nested look join)
- `드라이빙 테이블`의 데이터 1건 당 `드리븐 테이블`을 반복해서 검색하는 방식   
```sql
select 학생.학번, 학생.이름, 비상연락망.관계, 비상연락망.연락처
from 학생
JOIN 비상연락망
	ON 학생.학번 = 비상연락망.학번
WHERE 학생.학번 IN (1, 100);
```
- 위 쿼리에서 PK, 인덱스가 사용되지 않은 경우 NL Join 절차 (학생 테이블 100건, 비상연락망 1000건)
  - 학생 테이블에서 학번이 1을 찾기 위해 학생 테이블 풀스캔 (100건)
  - 학생 테이블에서 조회된 학번 1로 비상연락망 테이블 풀스캔 (1000건)
  - 위 작업을 학번 100에 대해 반복
  - 총 2200건의 데이터 접근이 발생

#### 블록 중첩 루프 조인 (BNL, block nested loop join)
- `드라이빙 테이블`에 인덱스가 존재하고 `드리븐 테이블`에 인덱스가 없는 경우 중첩 루프 조인을 수행하면 `드라이빙 테이블`의 결과만큼 `드리븐 테이블`을 풀스캔해야 하는 비효율이 발생한다.
- 블록 중첩 루프 조인은 위와 같은 문제를 `조인 버퍼`를 도입해서 해결한다.
- 블록 중첩 루프 조인 수행 절차
1. `드라이빙 테이블`의 결과를 버퍼의 크기만큼 `조인 버퍼`에 적재한다.
2. `조인 버퍼`가 가득차면 버퍼의 데이터를 `드리븐 테이블`과 조인한다.
3. `드라이빙 테이블`을 모두 조회할 때까지 1,2를 반복한다.
- `드리븐 테이블`이 인덱스의 부재로 풀스캔으로 성능이 저하되는 것을 개선하는 조인 알고리즘이다.

#### 배치 키 액세스 조인 (BKA, batched ky access join)
- 중첩 루프 조인 방식은 필연적으로 데이터 접근 시 랜덤 엑세스가 발생한다.
  - 즉, 데이터 범위가 넓다면 비효율적인 조인방식이 된다.
- `배치 키 액세스 조인` 은 랜덤 엑세스의 비효율을 해결하고자 하는 조인 알고리즘이다.
- `드라이브 테이블`은 블록 중첩 루프 조인의 `조인 버퍼` 개념을 그대로 사용한다.
- 추가로 `드리븐 테이블`에서 필요한 데이터를 예측해서 정렬된 상태로 담는 `랜덤 버퍼`의 개념을 도입한다.
  

***
<br>

### 오브젝트 스캔
- 테이블 스캔 (풀 스캔): 바로 디스크에 위치한 테이블 데이터에 접근
- 인덱스 스캔: 인덱스로 테이블 데이터를 찾아 접근
  - 인덱스 범위 스캔
  - 인덱스 풀 스캔
  - 인덱스 고유 스캔

#### 테이블 풀 스캔
- 인덱스를 거치지 않고 바로 테이블로 직행해서 처음부터 끝까지 읽는 방식이다.
- `Where` 절에 인덱스가 없거나, 전체 데이터 대비 조회할 데이터 량이 많은 경우 `테이블 풀 스캔`을 수행한다.  

#### 인덱스 범위 스캔
- 인덱스를 범위 기준으로 스캔한 결과로 테이블의 데이터를 찾는 방식
- `Between ~ And ~`, `<>`, `Like` 등 비교연산이 포함된 경우 `인덱스 범위 스캔`을 수행한다.
- 좁은 범위를 스캔할 때에는 매우 효율적이지만 범위가 넓은 경우 비효율적인 방식이다.

#### 인덱스 풀 스캔
- 인덱스를 처음부터 끝까지 스캔하는 방식
- 데이터 테이블에 접근하지 않고 인덱스로만 구성된 열 정보만을 요구하는 SQL에서 수행된다.
- 인덱스는 테이블보다는 상대적으로 적은 양으로 `테이블 풀 스캔`보다는 성능상 유리하지만 전 영역을 검색하는 방식보다는 검색 범위를 줄이는 쪽으로 튜닝해야 한다.  

#### 인덱스 고유 스캔
- 기본 키, 고유 인덱스로 테이블에 접근하는 방식 (인덱스를 사용하는 가장 효율적인 스캔 방법)
- `where` 절의 조건에서 사용되는 컬럼이 기본 키 혹은 고유 인덱스로 설정된 경우 활용된다.


***
<br>

### 디스크 접근 방식
- MySQL은 `페이지`를 데이터의 최소 단위로 가지고 `페이지 단위`로 읽고 쓸 수 있다.
- `시퀀셜 액세스`: 서로 연결된 페이지를 차례대로 읽는 경우
- `랜덤 액세스` : 원하는 페이지를 임의로 읽는 경우

#### 시퀀셜 액세스
- 물리적으로 인접한 페이지를 차례대로 읽는 방식
- `테이블 풀 스캔` 에서 활용되는 접근 방식이다.
- `테이블 풀 스캔` 의 경우 인접한 페이지 여러 개를 읽는 `다중 페이지 읽기` 방식으로 수행된다.


#### 랜덤 액세스
- 물리적으로 떨어진 페이지에 입의로 접근하는 방식 (페이지의 물리적 위치 고려 X)
- 페이지에 접근하는 디스크 헤더가 순서없이 이동하는 만큼 디스크 헤더의 물리적인 움직임이 더 필요하고 다중 페이지 읽기가 불가능하다.
- `랜덤 액세스`의 경우 최소한의 페이지에만 접근하도록 범위를 제한하고 인덱스를 사용하는 등 튜닝을 필요로 한다.


***
<br>

### 조건 유형
- `Where`절의 조건문을 기준으로 디스크에 접근하게 된다.
- `Where`절의 조건문으로 액세스한 데이터를 가져오고, 가져온 데이터에서 출력할 데이터를 다시 한 번 추출한다.
- `Where`절을 통해 디스크에서 데이터를 검색하는 조건을 `액세스 조건`이라 한다.
- 디스크에서 가져온 데이터에서 가공 및 연산을 수행하는 것을 `필터 조건`이라 한다.

#### 액세스 조건
- 디스크의 데이터에 어떻게 접근할 것인지에 대한 조건으로 SQL 튜닝의 핵심이다.
- 옵티마이저에 의해 `Where` 절의 특정 조건문을 액세스 조건으로 사용한다.
```sql
select * from tbl
WHERE ID=1 AND CODE='A';
```
- 위와 같은 SQL문이 있을 때 옵티마이저는 `ID`로 생성된 인덱스를 활용한다. `ID=1`을 액세스 조건으로 사용하는 것이다.
- 만약 `CODE='A'`를 액세스 조건으로 사용했다면 인덱스가 사용되지 않고 엄청난 양의 데이터를 스캔해야 할 것이다.


#### 필터 조건
- `액세스 조건`으로 가져온 데이터에서 불필요한 부분을 제거하거나 가공하는 조건이다.
```sql
select * from tbl
WHERE ID=1 AND CODE='A';
```
- 위 쿼리에서 `ID=1`이 `액세스 조건`으로 사용됐고 `CODE='A'`는 `필터 조건`으로 사용된다.
- `액세스 조건`에 의해 가져온 데이터에서 `필터 조건`으로 필터링 할 데이터가 없다면 좋은 SQL문이다.
  반대로 `필터 조건`에 의해 많은 데이터가 필터링된다면 비효율적인 SQL문에 해당한다.
- 이유는 `액세스 조건`에 의해 스토리지 엔진에서 MySQL엔진으로 데이터를 전달하는 오버헤드가 크다.
  따라서 `필터 조건`에 의해 필터링 될 데이터라면 애초에 가져오지 않는 것이 성능상 유리하다.


***
<br>

### 응용 용어

#### 선택도
- 특정 열을 기준으로 해당 열의 조건절에 따라 선택되는 데이터의 비율
- `선택도가 높다`: 중복되는 데이터가 많다. (조건절에 따라 대량의 데이터가 조회된다.)
- `선택도가 높다`: 중복되는 데이터가 적다.
```sql
선택도 계산

선택도 = 선택한 데이터 건수 / 전체 데이터 건수

select 1 / count(distinct 컬럼1)
from 테이블
```

#### 카디널리티
- 전체 행에서 특정 열에 대한 중복 수치
- 카티널리티 = (전체 데이터 건수 * 해당 열의 선택도)
- 특정 열에 중복된 값이 많다면 => 카디널리티가 낮다.
  - 카디널리티가 낮은 칼럼을 대상으로 조회하면 많은 양의 데이터를 거르지 못하고 다 조회될 것이다.
- 특정 열에 중복된 값이 적다면 => 카디널리티가 높다.
  - 카디널리티가 높은 칼럼을 대상으로 조회하면 많은 데이터를 제거하고 적은 데이터만을 조회할 수 있다.
  

#### Hint
- SQL문으로 뒤죽박죽 섞인 데이터를 찾아내라는 어려운 문제를 내기 앞서 데이터베이스에게 전달하는 `Hint`
```sql
[ 학생 이름 칼럼은 인덱스로 설정된 상태 (학생_IDX1) ]
select 학생, 전공코드
from 학생
where 이름 = '유재석';
```
- 명시적으로 인덱스를 사용하라는 힌트를 작성할 수 있다.
```sql
select 학생, 전공코드
from 학생 /*! USE INDEX (학생_IDX1) */
where 이름 = '유재석';

또는

select 학생, 전공코드
from 학생 USE INDEX (학생_IDX1)
where 이름 = '유재석';
```

```
실무에 자주 사용되는 Hint

STRAIGHT_JOIN : From 절에 작성된 테이블 순으로 조인을 유도
USE INDEX : 특정 인덱스를 사용하도록 유도
FORCE INDEX : 특정 인덱스를 사용도록 강제로 유도
IGNORE INDEX : 특정 인덱스를 사용하지 않도록 유도

명시적으로 Hint를 작성해도 옵티마이저가 반드시 힌트를 참고하는 것은 아니다.
```

#### 콜레이션 Collation
- 특정 문자셋으로 DB에 저장된 값을 비교하거나 정렬하는 작업의 규칙
```
a와 A 중 무엇이 더 큰가?
a와 b 중 무엇이 더 큰가?
```
- 많이 사용되는 콜레이션
  - utf8_bin
  - utf8_general_ci
- 콜레이션은 데이터베이스 단위, 테이블 단위, 열 단위까지 설정 가능하다.
  - 더 자세한 곳에 설정한 콜레이션이 덜 자세한 곳에 설정된 콜레이션을 덮어쓴다.
```sql
[ 테이블에 collation 설정 ]

create table 테이블 (
	칼럼1,
	칼럼2,
)
COLLATE='utf8_general_ci';
```

#### 캐릭터셋 vs 콜레이션
- Character set: 데이터를 어떻게 저장할 것인가??
  - 다국어, 영문+숫자
  - ex) `utf8`(다국어), `utf8mb4`(다국어 + 이모지) 
- Collation: 데이터를 어떻게 정렬할 것인가??






















