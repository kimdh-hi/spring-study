## 9장 일반적인 프로그래밍 원칙

- 지역변수, 제어구조, 라이브러리, 데이터 타입
- 리플렉션, 네이티브 메서드
- 최적화, 명명 규칙

<br>

### 지역변수의 범위를 최소화하라

지역변수의 유효범위를 최소로 줄이면 코드 가독성 및 유지보수성이 높아지고 오류 가능성은 낮아진다.

#### 지역변수의 범위를 줄이는 가장 강력한 방법
- **가장 처음 쓰일 때 선언하기**

#### 거의 모든 지역변수는 선언과 동시에 초기화해야 한다.
- 초기화에 필요한 정보가 충분하지 않다면 충분해질 때까지 **선언**을 미룬다.

#### 메서드를 작게 유지하고 한 가지 기능에 집중하도록 분리한다.

***

### 전통적인 for문보다는 for-each 문을 사용하라
- `for-each`는 반복자와 인덱스 변수를 사용하지 않는 for문이다.
- 배열과 컬렉션 모두 순회가능하다.
- 배열, 컬렉션과 더불어 `Iterable`인터페이스를 구현한 객체 모두를 순회할 수 있다.

> 전통적인 for문에 비해 성능저하가 없다.

***

### 정확한 답이 필요하다면 float와 double은 피하라
`float`와 `double`은 넓은 범위 수의 부동소수점 연산에 쓰이고 `근사치` 계산에 사용된다.

#### float와 double은 금융 관련 계산과는 맞지 않는다.
- 금융 계산에는 `BigDecimal`을 사용하자.
  but, 사용하기 불편하고 느리다..
- 다른 대안으로 `int` 또는 `long` 타입을 사용할 수 있다.
  사용 가능한 값을 범위가 크게 줄어들고 소수점 이하 값을 따로 관리해야 하는 불편함이 있다.

***

### 박싱된 기본 타입보다는 기본 타입을 사용하라
`오토 박싱`과 `오토 언박싱`으로 박싱타입과 기본타입을 구분하지 않고 사용할 수 있지만 반드시 주의하고 구분해서 사용해야 한다.

#### 기본타입 - 박싱된 기본 타입
1. 기본 타입은 값만, 박싱된 기본 타입은 값에 식별성까지 갖는다.
2. 기본 타입은 항상 유효한 값을 같지만, 박싱된 기본타입은 null을 가질 수 있다.
3. 기본 타입이 박싱된 기본 타입보다 시간, 메모리 사용면에서 더 효율적이다.

#### 박싱된 기본 타입에 `==` 연산자 사용시 오류가 발생한다.
- 박싱된 기본 타입은 `식별성`을 갖고 있으므로 `==` 연산시 값이 아닌 `식별성`으로 동등성 여부를 검사한다.

#### 기본타입과 박싱된 기본타입을 혼용한 연산에서는 박싱된 기본 타입의 박싱이 자동으로 풀린다.
```java
public class Unbelievable{
	static Integer i;

	public static void main(String[] args) {
		if (i == 42) {
			System.out.println("Unbelievable");
		}
	}
}
```

`i`와 `42`를 비교하고 있다.
- `i`는 값이 할당되지 않았지만 박싱 타입이므로 `NPE`를 발생시키지 않을 것이라 생각한다.
- `NPE`가 발생한다.
- 42는 기본 타입(`int`)이다. 
- 박싱된 기본 타입과 기본 타입을 혼용하여 연산하면 박싱된 기본 타입의 박싱이 자동으로 풀린다.
  즉, `Null`인 기본타입을 참조한 꼴이 되는 것이다.


#### 기본타입 -> 박싱된 기본타입 으로 발생하는 성능저하에 유의해야 한다.
```java
public static void main(String[] args) {
	Long sum = 0L; // 박싱된 기본 타입
	for (long i=0;i <= Integer.MAX_VALUE; i++) {
		sum += i; // 박싱된 기본 타입 객체 생성
	}
}
```  
- 결과는 예상한 대로 나오겠지만 체감될 만큼 느리다.
- `sum += i` ....


#### 박싱된 기본 타입은 왜 써?..
1. 컬렉션의 원소, 키, 값 등에는 기본 타입을 사용할 수 없어서 사용한다.
2. 매개변수화 타입도 마찬가지로 박싱된 기본 타입을 사용한다.

***

### 문자열 연결은 느리니 주의하라
- `문자열 연결 연산자` (+) 로 n개 문자열을 연결하는 것은 `n^2`의 시간이 소요된다. 
- 문자열은 불변이다. 문자열을 연결한다면 두 문자열을 모두 복사해서 새로 만들어줘야 한다.

#### 문자열 연결 연산자 대신 StringBuilder를 사용하자.

***

### 객체는 인터페이스를 사용해 참조하라

적합한 인터페이스만 있다면 매개변수뿐 아니라 반환값, 변수, 필드를 전부 **인터페이스 타입으로 선언**하라

```java
// O
Set<Son> set = new LinkedHashSet<>();

// X
LinkedHashSet<Son> set = new LinkedHashSet<>();
```

#### 인터페이스를 타입으로 사용하는 습괍을 길러두면 프로그램이 훨씬 유연해질 수 있다.
- 인터페이스를 타입으로 사용하면 구현 클래스 교체시 유연하게 변경 가능하다.
```java
Set<Son> set = new LinkedHashSet<>();
// 구현체 변경
Set<Son> set = new HashSet<>();
```
- 구현체에 따라 로직이 변경되는 것은 주의해야 한다.
- `LinkedHashSet`을 순회할 때는 순서를 보장하지만 `HashSet`을 순회할 때는 순서를 보장하지 않는 이런 특성을 주의해야 한다.

#### 적합한 인터페이스가 없는 경우 클래스의 계층구조 중 필요한 기능을 만족하는 가장 덜 구체적인 클래스를 타입으로 사용하자


***

### 리플랙션보다는 인터페이스 사용하라

`java.lang.reflect`를 이용하면 임의 클래스에 접근 가능하다.

`Class`객체가 주어지면 아래 인스턴스를 가져올 수 있다.
- 생성자 `Constructor`
- 메서드 `Method`
- 필드 `Field`

위 세 인스턴스를 통해 생성자, 메서드, 필드를 직접 조작하는 것이 가능하다.
인스턴스 생성, 메서드 호출, 필드 접근 ...

리플렉션을 이용하면 컴파일 당시 존재하지 않던 클래스도 이용 가능하다. (단점이 있다.)
- **컴파일 타임의 타입 검사, 예외검사가 의미 없다.**
  리플랙션을 이용해서 존재하지 않는, 접근할 수 없는 메서드를 호출하려 한다면 런타임 오류가 발생할 수 있다.
- **리플랙션을 이용하면 코드가 지저분하고 장황해진다.**
- **성능이 떨어진다.**
  리플랙션을 통한 메서드 호출은 일반 메서드 호출보다 훨씬 느리다.

> **리플렉션**은 단점을 수반하는 기능이다. 사용에 주의하자.
만약 컴파일 타임에 알 수 없는 클래스를 사용해야 해서 리플렉션을 사용한다면 **객체 생성에만 리플렉션을 사용**하고 생성된 객체는 적절한 인터페이스나 상위 클래스로 형변환해 사용하도록 하자.

***

### 네이티브 메서드는 신중히 사용하라

> 네이티브 메서드
C, C++ 같은 네이티브 프로그래밍 언어로 작성한 메서드

**자바 네이티브 인터페이스** (Java Native Interface, JNI)
- 자바 프로그램이 네이티브 메서드를 호출하는 기술

#### 플랫폼(OS...) 특화 기능을 활용하기 위해 네이티브 메서드를 사용한다.
- 하지만 차츰 Java도 OS같은 하부 플랫폼의 기능을 흡수하고 있다.
  네이티브 메서드를 사용할 필요가 줄어들고 있는 것이다.
- 자바 9는 `process API`를 추가해서 OS 프로세스에 접근하는 길을 열어주었다.

  
#### 성능 개선 목적 네이티브 메서드 사용은 거의 권장하지 않는다.
- JVM은 그동안 엄청난 속도로 발전했다.
  대부분의 작업에서 Java는 다른 플랫폼에 견줄만한 성능을 보인다.
- 네이티브 언어는 메모리를 안전하게 관리해주지 않는다. 때문에 네이티브 메서드는 메모리 관련 오류를 발생시키기 쉽다.
- `GC`는 네이티브 메모리를 회수하지 못한다.

   








































