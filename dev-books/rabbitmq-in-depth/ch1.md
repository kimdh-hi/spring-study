## ch1 

### RabbitMQ 의 장점
- 경량성
  - 관리자 UI 플러그인과 코어 애플리케이션을 구동하는데 40mb 미만의 메모리를 사용한다.
  - 메모리 사용량은 큐에 전송되는 메시지가 증가함에 따라 증가한다.
- 유연한 성능과 안정성 절충 제어
  - 안정적인 메시지
    - 메시지를 전송하기 전 디스크에 저장할 수 있는 옵션을 제공한다.
  - 클러스터 설정시 큐를 HA로 설정학소 여러 노드에 걸쳐 저장하면서 일부 서버의 장애로 인해 메시지가 손실되지 않도록 할 수 있다.


### RabbitMQ 와 AMQP
RabbitMQ 는 AMQP 스펙을 구현한 최초의 브로커 중 하나이다.
RabbitMQ 는 AMQP 를 기반으로 구현됐지만 MQTT, STOMP, XMPP 등 다양한 프로토콜도 제공한다.


### 느슨하게 결합된 아키텍처
```
사용자가 로그인 시 여러 DB 서버에 있는 테이블들에 로그인 시간을 기록해야 한다. (로그인 시간 실시간 기록)

로그인 -> 서버1 DB 회원 데이터 갱신 -> 서버2 DB 회원 데이터 갱신 -> ... -> 인증완료

로그인 시간을 갱신하는 부분이 이전 작업을 기다리며 동기적으로 발생하기 때문에 성능상 치명적이다.
```
로그인과 로그인 시간을 갱신하는 DB 업데이트 작업이 강하게 결합되어 있어서 발생하는 결과이다.
MQ 를 도입해서 두 작업을 분리하면 로그인 성공 후 클라이언트는 DB 갱신 작업을 기다리지 않아도 된다.


### 데이터베이스 쓰기 의존성 제거
RabbitMQ 와 같은 메시지 기반 미들웨어를 도입하면 DB 쓰기 작업을 메시징을 통해 비동기적으로 수행할 수 있다.
DB 쓰기 명령을 DB에 직접 날리지 않고, 쓰기 작업에 대한 메시지를 발행하고 소비자 측에서 비동기적으로 메시지를 받아 쓰기 작업을 수행한다.
더 이상 쓰기 작업에 대한 결과를 기다릴 필요가 없다.

위와 같은 구조는 DB의 유지보수 측면에서의 장점도 제공한다.
DB서버에 어떤 작업으로 DB 작업이 불가능할 때 앞 단의 소비자 애플리케이션을 잠시 멈추면 된다. 이 때 소비되지 않은 DB 작업을 위한 메시지들은 메시지 큐에 큐잉된 채로 기다린다. 이후 소비자 애플리케이션 재구동되면 DB 작업을 위한 메시지를 처리할 수 있다.


### AMQ 모델
AMQ 모델은 메시지 라우팅 동작을 정의하는 메시지 브로커의 세 가지 개념을 정의한다.
- `Exchange` : 메시지 브로커에서 큐에 메시지를 전달한다.
- `Queue` : 메시지를 저장하는 디스크 혹은 메모리 상의 자료구조
- `Binding` : `Exchange` 에 도달한 메시지가 어떤 `Queue` 에 저장되어야 하는지를 정의한다.

#### Exchange

Exchange 는 RabbitMQ 로 전송된 메시지를 수신하고 메세지를 보낼 위치(큐)를 결정한다.
RabbitMQ 는 위와 같은 라우팅 동작을 처리하는 여러 유형의 Exchange 가 존재한다.
추가로 플러그인을 통해 직접 커스텀 익스체인지를 정의하는 것도 가능하다.

#### Queue

Queue 는 수신한 메시지를 저장한다.
Queue 에는 메시지에 수행하는 작업을 정의하는 정보가 있다. (옵션? 속성?)

Queue 설정정보
- 메모리에만 저장?
- 소비자에게 전달 전 FIFO 순서로 메시지를 디스크에 저장?

#### Binding
Binding 은 Queue 와 Exchange 의 관계를 정의한다.
RabbitMQ 는 `Binding` 과 `Binding-key` 를 통해 Exchange 에 전달된 메시지를 어떤 Queue에 전달할지를 결정하낟.

애플리케이션에서 Exchnage 로 메시지를 보낼 때에는 `Routing-key` 속성을 사용한다.
`Routing-key` 는 기본적으로는 Queue 의 이름이다.
Exchange 의 유형에 따라 `Routing-key` 를 큐의 이름으로 사용할지, 패턴에 매칭시킬지, 속성을 우선적으로 판단할지가 결정된다.