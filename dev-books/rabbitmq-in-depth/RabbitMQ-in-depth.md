
## ch1 

### RabbitMQ 의 장점
- 경량성
  - 관리자 UI 플러그인과 코어 애플리케이션을 구동하는데 40mb 미만의 메모리를 사용한다.
  - 메모리 사용량은 큐에 전송되는 메시지가 증가함에 따라 증가한다.
- 유연한 성능과 안정성 절충 제어
  - 안정적인 메시지
    - 메시지를 전송하기 전 디스크에 저장할 수 있는 옵션을 제공한다.
  - 클러스터 설정시 큐를 HA로 설정학소 여러 노드에 걸쳐 저장하면서 일부 서버의 장애로 인해 메시지가 손실되지 않도록 할 수 있다.


### RabbitMQ 와 AMQP
RabbitMQ 는 AMQP 스펙을 구현한 최초의 브로커 중 하나이다.
RabbitMQ 는 AMQP 를 기반으로 구현됐지만 MQTT, STOMP, XMPP 등 다양한 프로토콜도 제공한다.


### 느슨하게 결합된 아키텍처
```
사용자가 로그인 시 여러 DB 서버에 있는 테이블들에 로그인 시간을 기록해야 한다. (로그인 시간 실시간 기록)

로그인 -> 서버1 DB 회원 데이터 갱신 -> 서버2 DB 회원 데이터 갱신 -> ... -> 인증완료

로그인 시간을 갱신하는 부분이 이전 작업을 기다리며 동기적으로 발생하기 때문에 성능상 치명적이다.
```
로그인과 로그인 시간을 갱신하는 DB 업데이트 작업이 강하게 결합되어 있어서 발생하는 결과이다.
MQ 를 도입해서 두 작업을 분리하면 로그인 성공 후 클라이언트는 DB 갱신 작업을 기다리지 않아도 된다.


### 데이터베이스 쓰기 의존성 제거
RabbitMQ 와 같은 메시지 기반 미들웨어를 도입하면 DB 쓰기 작업을 메시징을 통해 비동기적으로 수행할 수 있다.
DB 쓰기 명령을 DB에 직접 날리지 않고, 쓰기 작업에 대한 메시지를 발행하고 소비자 측에서 비동기적으로 메시지를 받아 쓰기 작업을 수행한다.
더 이상 쓰기 작업에 대한 결과를 기다릴 필요가 없다.

위와 같은 구조는 DB의 유지보수 측면에서의 장점도 제공한다.
DB서버에 어떤 작업으로 DB 작업이 불가능할 때 앞 단의 소비자 애플리케이션을 잠시 멈추면 된다. 이 때 소비되지 않은 DB 작업을 위한 메시지들은 메시지 큐에 큐잉된 채로 기다린다. 이후 소비자 애플리케이션 재구동되면 DB 작업을 위한 메시지를 처리할 수 있다.


### AMQ 모델
AMQ 모델은 메시지 라우팅 동작을 정의하는 메시지 브로커의 세 가지 개념을 정의한다.
- `Exchange` : 메시지 브로커에서 큐에 메시지를 전달한다.
- `Queue` : 메시지를 저장하는 디스크 혹은 메모리 상의 자료구조
- `Binding` : `Exchange` 에 도달한 메시지가 어떤 `Queue` 에 저장되어야 하는지를 정의한다.

#### Exchange

Exchange 는 RabbitMQ 로 전송된 메시지를 수신하고 메세지를 보낼 위치(큐)를 결정한다.
RabbitMQ 는 위와 같은 라우팅 동작을 처리하는 여러 유형의 Exchange 가 존재한다.
추가로 플러그인을 통해 직접 커스텀 익스체인지를 정의하는 것도 가능하다.

#### Queue

Queue 는 수신한 메시지를 저장한다.
Queue 에는 메시지에 수행하는 작업을 정의하는 정보가 있다. (옵션? 속성?)

Queue 설정정보
- 메모리에만 저장?
- 소비자에게 전달 전 FIFO 순서로 메시지를 디스크에 저장?

#### Binding
Binding 은 Queue 와 Exchange 의 관계를 정의한다.
RabbitMQ 는 `Binding` 과 `Binding-key` 를 통해 Exchange 에 전달된 메시지를 어떤 Queue에 전달할지를 결정하낟.

애플리케이션에서 Exchnage 로 메시지를 보낼 때에는 `Routing-key` 속성을 사용한다.
`Routing-key` 는 기본적으로는 Queue 의 이름이다.
Exchange 의 유형에 따라 `Routing-key` 를 큐의 이름으로 사용할지, 패턴에 매칭시킬지, 속성을 우선적으로 판단할지가 결정된다.


---

## ch2

### RPC 전송으로서의 AMQP

```
RPC
한 컴퓨터에서 다른 컴퓨터의 프로그램이나 메서드를 원격에서 실행할 수 있게 해주는 컴퓨터 간 통신 유형 중 하나이다.
API 를 통하는 웹 또한 RPC 패턴 중 하나로 볼 수 있다.
```

RabbitMQ 와 통신 시 발생하는 RPC 는 웹 기반 API 와는 다른 부분이 많다.
웹 API 의 경우 클라이언트가 명령을 실행하고 서버가 응답을 보내는 구조이다.
서버가 클라이언트로 명령을 다시 보내지는 않는다. (클라이언트 -> 서버 API)

반면 AMQP 스펙의 경우 서버와 클라이언트 모두 명령을 실행할 수 있다.
클라이언트 측도 서버로부터 메시지를 받을 수 있도록 큐 서버를 구독하고 있어야 한다.

### 올바른 채널로 튜닝
양방향 라디오와 유사하게 AMQP 스펙에는 RabbitMQ 와 통신하기 위한 `채널`이 존재한다.
채널은 연결협상이 완료된 AMQP 연결을 정보전송을 위한 `수도관`으로 사용된다.
이 정보전송을 위한 `수도관(채널)` 은 다른 채널으로부터 격리된다.
단일 AMQP 연결에는 여러 채널이 존재하므로 여러 메시지 대화를 수행할 수 있다. 이를 `멀티플렉싱` 이라 한다.

```
RabbitMQ 사용시 너무 많은 채널을 사용하는 것은 좋지 않다.
RabbitMQ 서버와 클라이언트에서 채널은 많은 리소스를 차지않다. 각 채널마다 메모리 구조와 객체가 설정되기 때문이다.
채널이 많을수록 RabbitMQ 는 이를 관리하는데 더 많은 메모리를 사용해야 한다.
적당한? 채널을 유지하는 것이 좋다.
```

### AMQP의 RPC 프레임 구조
AMQP 스펙은 객체지향에서의 개념과 비슷한 `클래스` 와 `메서드`를 사용하여 `AMQP 명령어`를 정의한다.
각 클래스에는 각 작업을 위한 AMQP 메서드가 존재한다.
연결협상 과정에서 연결협상 과정에서 `Connection.Start` 명령어를 클라이언트로 전송한다.
여기서 `Connection` 은 클래스에 `Start` 는 메서드에 해당한다.

### AMQP 프레임?
RabbitMQ 에서 AMQP 명령어를 전송하거나 수신할 때 필요한 모든 인자들은 `프레임`으로 인코딩되서 전송된다.
프레임은 명령과 인자를 인코딩해서 각 프레임이 서로 구분되도록 하는 효율적인 방법이다.

`프레임`은 `열차의 한 칸`과 유사하다.
열차 한 칸은 `서로 동일한 기본 구조`로 되어있고 `내용으로 서로 구분`된다.

AMQP 프레임은 5개 요소로 구성된다.
- 프레임 유형
- 채널 번호
- 프레임 크기(byte)
- 프레임 페이로드
- 끝 바이트 표시

AMQP 프레임의 헤더는 세 개 필드로 구성된다.
- 프레임 헤더
  - 프레임 유형: 단일 바이드
  - 채널 번호: 프레임이 속하는 채널을 지정
  - 프레임 크기: 프레임 본문의 크기

### 프레임 유형

- 프로토콜 헤더 프레임
  - RabbitMQ 연결시 한 번만 사용된다.
- 메서드 프레임
  - RabbitMQ 와 서로 주고받는 RPC 요청이나 응답을 전송한다.
- 콘텐츠 헤더 프레임
  - `메시지의 크기`와 속성을 포함한다.
- 바디 프레임
  - `메시지의 내용`을 포함한다.
- 하트비트 프레임
  - RabbitMQ 와 연결된 클라이언트와 서버가 주고받으면서 서로 사용 가능한 상태인지 확인한다.

```
하트비트
RabbitMQ 는 클라이언트에 하트비트를 보내고 응답이 오지 않는다면 클라이언트와 연결을 끊는다.
보통 비동기 환경에서는 큰 값을 설정한다. (보통 비동기를 위해 사용하니 그냥 큰 값을.)

하트비트 간격을 0으로 설정하는 하트비트를 끌 수 있다.
```

### 메시지 프레임 마샬링
RabbitMQ 에서 메시지 발생시 메서드 프레임, 헤더 프레임, 바디 프레임이 사용된다.

첫 번째 전송되는 프레임은 `메서드 프레임` 이다.
`메서드 프레임` 은 익스체인지와 라우팅키를 포함한다.

다음으로 내용에 해당하는 `콘텐츠 헤더 프레임`과 `바디 프레임`이 전송된다.
`콘텐츠 헤더 프레임` 에는 본문의 크기와 메시지의 속성이 포함된다.

AMQP 는 최대 프레임 크기가 있고 이를 초과하는 경우 본문이 여러 `바디 프레임` 으로 분할된다.

메서드 프레임 -> 콘텐츠 헤더 프레임 -> 바디 프레임(하나 이상의)

효율적인 전송을 위해 메서드 프레임과 콘텐츠 헤더 프레임은 이진 데이터로 구성된다.
바디 프레임의 경우 압축이나 인코딩 되지 않은 데이터로 구성되고 일반 텍스트부터 이진 이미지 데이터까지 저장가능하다.

### 메서드 프레임
메서드 프레임 => RPC 요청을 처리할 클래스, 메서드, 인수(익스체인지, 라우팅 키)

메서드 프레임의 마지막은 `mandatory` 플래그이다.
이 플래그는 RabbitMQ가 메시지를 라우팅할 수 있는지 할 수 없는지를 알려준다.
라우팅 할 수 없는 경우 `Basic.Return` 프레임을 반환한다.

### 정상적인 에러 처리
RabbitMQ 에서 에러 발생시 에러 코드를 반환하고 채널을 닫는다.
ex) 같은 이름의 속성이 다른 큐를 정의하려는 경우 해당 RPC 명령을 보낸 채널을 닫는다.
ex) 가상호스트에 접근권한이 없는 사용자가 큐를 생성하려는 경우 403 에러를 반환하고 채널을 닫는다.

클라이언트 측에서 에러를 처리하려면 RabbitMQ 로부터 `Channel.Close` 를 받아 적절하게 응답해야 한다.
서버에서 전송한 에러에 대한 응답을 수신하지 않거나 적절하게 처리하지 않으면 `메시지가 손실`될 수 있다.

RabbitMQ 는 이미 닫힌 채널에 메시지를 발행하는 경우 알아서 연결을 종료한다.


### 존재하지 않는 익스체인지에 메시지를 발행하는 경우
기본적으로 메시지는 버려진다.
메시지가 익스체인지에 제대로 발행됐는지 확인하려면 메시지 발생시 `메서드 프레임` 의 `mandatory` 플래그를 `true`로 설정하거나 `발행자 확인` 을 사용해야 한다. (but, 메시지 발행 속도가 저하될 수 있다.)


### 메시지 발행
1. 메서드 프레임에 포함된 익스체인지 이름과 일치하는 익스체인지를 찾는다.
2. 익스체인지 내부에 바인딩을 평가하며 메서드 프레임이 포함된 라우팅 키와 일치하는 큐를 찾는다.
3. 일치하는 큐를 찾으면 선입선출로 메시지를 큐에 삽입한다.

큐에 실제 메시지를 넣는 것은 아니고 메시지에 대한 `참조`가 큐에 삽입된다.

메시지의 참조본? 사본? 이 모두 소비되는 경우 RabbitMQ 는 메시지를 메모리에서 제거한다.






 







































