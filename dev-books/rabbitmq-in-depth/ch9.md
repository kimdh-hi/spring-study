## ch9
대체 프로토콜 사용

AMQP 0.9.1은 RabbitMQ와 통신하는 대부분 애플리케이션의 요구사항을 해결할 수 있는 프로토콜이지만, 특정 상황에서 다른 프로토콜이 더 나은 선택일 수 있다.

AMQP의 경우 대기시간이 길고 신뢰할 수 없는 모바일 기기와의 네트워킹에는 문제가 될 수 있다.
AMQP의 상태 기반 프로토콜은 클라이언트 애플리케이션의 연결이 짧게 유지되고 빠른 속도로 메시지를 발행해야 하는 `일부 응용 프로그램 환경에서 너무 복잡`할 수 있다.
일부 애플리케이션에 도입된 메시징 아키텍처가 AMQP 프로토콜을 지원하지 않을수도 있다.

위와 같은 경우에도 플러그인을 통해 메시징 아키텍처의 핵심 요소로 RabbitMQ 를 계속 사용할 수 있다.

####  MQTT 와 RabbitMQ
MQTT 프로토콜은 모바일 환경에서 널리 사용되는 경량 메시징 프로토콜이고 RabbitMQ 를 플러그인으로 사용할 수 있다.
`pub-sub` 패턴 기반 프로토콜로 설계된 MQTT는 메시지의 신뢰성을 보장하고 자원이 제한적인 장치와 저대역폭 환경에 적합하게 설계됐다.
AMQP 만큼 기능이 풍부하지 않지만 모바일 환경의 설장으로 인기가 많아졌다.

MQTT의 `LWT(Last Will and Testament)` 기능이 도움이 될 지 생각해봐야 한다.
`LWT` 를 사용하면 `클라이언트의 연결이 예상치 않게 끊어질 때, 발행해야 하는 메시지를 지정`할 수 있다.

MQTT의 최대 메시지 크기는 256MB이다. 이것으로 충분한지 고려해야 한다.

#### MQTT 프로토콜
AMQP 는 프로토콜 레벨에서 익스체인지, 큐와 같은 구조가 있지만 MQTT는 발행자와 소비자로만 구성된다.

RabbitMQ 를 사용하는 경우 `RabbitMQ에 발행된 MQTT 메시지`는 `AMQP를 통해 발행된 메시지처럼 취급`되고 `MQTT의 소비자`는 `AMQP 소비자처럼 취급`되기 때문에 RabbitMQ를 사용하는 경우 이 제한의 영향이 덜하다.

RabbitMQ에서 MQTT 를 구성할 수 있지만 MQTT와 AMQP를 통해 발행된 메시지의 프로토콜 특징 때문에 발생하는 차이점은 존재한다.
비교적 가벼운 프로토콜인 MQTT는 신뢰할 수 없는 네트워크 환경에 적합하다. 반면 AMQP 는 보다 안정적인 네트워크 환경에 적합하다.

#### MQTT 메시지 구조

헤더 
- 메시지 유형
메시지의 유형을 나타내는 4비트 값이다.
메시지 유형의 예로는 CONNECT, PUBLISH, SUBSCRIBE 가 있다.

- DUP 플래그
클라이언트 또는 서버가 메시지를 재전송할 수 있는데, 메시지가 재전송된 메시지인지를 나타내는 단일 비트 플래그이다.

- QoS 플래그
메시지의 서비스 품질을 나타내는 2비트 값이다.
```
MQTT의 QoS는

- 최대 한 번
- 적어도 한 번
- 정확히 한 번

메시지를 전달해야 하는지에 대한 설정이다.
```

- Retain 플래그
모든 구독자에게 메시지를 발행한 후 메시지를 유지해야 하는 서버에 알려주는 단일 비트 플래그이다.
MQTT 메시지 브로커는 유지 플래그가 설정된 경우 마지막 메시지만 유지하며, 새로운 구독자가 마지막 메시지를 수신할 수 있도록 한다.
Retain 플래그로 유지기능을 사용하는 경우 재연결 시 최신 메시지를 동기화할 수 있다.

페이로드 크기
- 메시지 페이로드의 크기를 지정한다.
- MQTT의 최대 페이로드 크기는 256MB 이다. (AMQP의 경우 16엑사바이트, RabbitMQ는 2GB로 제한한다.)


#### MQTT로 발행하기
MQTT의 토픽 이름은 메시지 발행에 대한 강력한 라우팅 도구로 사용된다.
MQTT 토픽 문자열은 메시지를 발행 할 때 슬래시를 구분자로 사용한다.

MQTT 클라이언트는 메시지 발행을 위해 `amp.topic` 익스체인지를 기본 익스체인지로 사용한다.
MQTT 플러그인은 MQTT 토픽 이름 값의 슬래시 문자를 AMQP 라우팅 키의 마침표로 변경한다. (`/` -> `.`)


#### MQTT 메시지 구독
메시지 구독을 위해 MQTT 를 통해 RabbitMQ에 연결할 때 RabbitMQ는 새로운 큐를 생성한다.
생성되는 큐의 이름은 `mqtt-subscriber-[NAME]qos[N]` 형식으로 지정된다.

`#` 은 AMQP와 동일하게 MQTT 에서도 다중 레벨 일치를 나타내지만 단일 레벨 일치에는 `*` 대신 `+` 를 사용한다.



모바일 장치를 위한 메시징 아키텍처의 핵심으로 RabbitMQ 를 고려한다면 MQTT와 RabbitMQ MQTT 플러그인 사용을 고려하는 것이 좋다.


---

#### HTTP 로 상태 없이 메시지 발행하기 (statelessd)

RabbitMQ에 연결을 유지하지 않고 메시지를 빠르게 발행해야 하는 환경에서는 AMQP, MQTT, STOMP 와 같은 상태 유지 프로토콜이 많은 비용을 치러야 한다.
메시지 관련 작업 수행 전 연결과 관련된 작업에 비용이 발생하기 때문에 짧은 연결에는 적합하지 않다.

`statelessd` 는 연결상태관리의 추가 부하 없이 고성능으로 메시지를 발행 가능한 HTTP에서 AMQP 메시지 발행을 목적으로 한다.


#### statelessd 개발 배경
RabbitMQ 는 상태 기반 프로토콜이다.
PHP의 경우 매 처리마다 RabbitMQ와 새로운 연결을 생성하고 메시지를 발행해야 하는 문제가 있었다.
RabbitMQ 와 연결은 만드는 것은 수 밀리초 단위이지만 1-2초 사이에 수십만 개의 메시지를 발행해야 했고 이 때 연결도 수십만 번 해야하는 것이 문제였다.

이런 문제를 해결하기 위해 HTTP와 AMQP 메시지 발행 게이트웨이인 statelessd를 개발했고 메시지 발행에 필요한 연결을 관리하면서 고속의 HTTP 요청을 받아들일 수 있게 되었다.

statelessd 는 HTTP 를 통해 메시지를 발행하는 클라이언트가 기본 HTTP 규칙을 사용해 기본 AMQP 메시지를 발행하는데 필요한 모든 정보를 전달하도록 설계했다.

HTTP URI의 경로는 메시지를 발행하는 RabbitMQ의 가상 호스트를 시작으로 사용할 익스체인지나 라우팅 키로 구성된다.
```
http://host[:port]/<virtual-host>/exchange/routing-key
```

statelessd 데몬은 요청을 받으면 연결 스택에 RabbitMQ 사용자 이름, 암호 및 가상 호스트 조합이 있는지 확인한다.
(사용자 이름, 암호는 basic auth 헤더를 사용한다)
조합이 발견되면 열린 연결? 을 사용해 메시지를 발행하고 204로 응답한다.

statelessd 요청은 POST가 사용되고 폼 데이터(form-encoded)로 메시지의 본문과 속성이 전달된다.


#### 요약

RabbitMQ 는 AMQP 뿐 아니라 STOMP, MQTT 와 같은 프로토콜을 지원한다.
네트워크가 빈번하게 끊어지거나 느린 발행속도가 발생하는 모바일 환경의 경우 MQTT를 사용할 수 있다.
특정 상황에서는 statelessd를 사용해서 HTTP 요청으로 메시지를 처리할 수도 있다.

