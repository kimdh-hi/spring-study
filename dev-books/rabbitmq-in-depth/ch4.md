
## ch1 

### RabbitMQ 의 장점
- 경량성
  - 관리자 UI 플러그인과 코어 애플리케이션을 구동하는데 40mb 미만의 메모리를 사용한다.
  - 메모리 사용량은 큐에 전송되는 메시지가 증가함에 따라 증가한다.
- 유연한 성능과 안정성 절충 제어
  - 안정적인 메시지
    - 메시지를 전송하기 전 디스크에 저장할 수 있는 옵션을 제공한다.
  - 클러스터 설정시 큐를 HA로 설정학소 여러 노드에 걸쳐 저장하면서 일부 서버의 장애로 인해 메시지가 손실되지 않도록 할 수 있다.


### RabbitMQ 와 AMQP
RabbitMQ 는 AMQP 스펙을 구현한 최초의 브로커 중 하나이다.
RabbitMQ 는 AMQP 를 기반으로 구현됐지만 MQTT, STOMP, XMPP 등 다양한 프로토콜도 제공한다.


### 느슨하게 결합된 아키텍처
```
사용자가 로그인 시 여러 DB 서버에 있는 테이블들에 로그인 시간을 기록해야 한다. (로그인 시간 실시간 기록)

로그인 -> 서버1 DB 회원 데이터 갱신 -> 서버2 DB 회원 데이터 갱신 -> ... -> 인증완료

로그인 시간을 갱신하는 부분이 이전 작업을 기다리며 동기적으로 발생하기 때문에 성능상 치명적이다.
```
로그인과 로그인 시간을 갱신하는 DB 업데이트 작업이 강하게 결합되어 있어서 발생하는 결과이다.
MQ 를 도입해서 두 작업을 분리하면 로그인 성공 후 클라이언트는 DB 갱신 작업을 기다리지 않아도 된다.


### 데이터베이스 쓰기 의존성 제거
RabbitMQ 와 같은 메시지 기반 미들웨어를 도입하면 DB 쓰기 작업을 메시징을 통해 비동기적으로 수행할 수 있다.
DB 쓰기 명령을 DB에 직접 날리지 않고, 쓰기 작업에 대한 메시지를 발행하고 소비자 측에서 비동기적으로 메시지를 받아 쓰기 작업을 수행한다.
더 이상 쓰기 작업에 대한 결과를 기다릴 필요가 없다.

위와 같은 구조는 DB의 유지보수 측면에서의 장점도 제공한다.
DB서버에 어떤 작업으로 DB 작업이 불가능할 때 앞 단의 소비자 애플리케이션을 잠시 멈추면 된다. 이 때 소비되지 않은 DB 작업을 위한 메시지들은 메시지 큐에 큐잉된 채로 기다린다. 이후 소비자 애플리케이션 재구동되면 DB 작업을 위한 메시지를 처리할 수 있다.


### AMQ 모델
AMQ 모델은 메시지 라우팅 동작을 정의하는 메시지 브로커의 세 가지 개념을 정의한다.
- `Exchange` : 메시지 브로커에서 큐에 메시지를 전달한다.
- `Queue` : 메시지를 저장하는 디스크 혹은 메모리 상의 자료구조
- `Binding` : `Exchange` 에 도달한 메시지가 어떤 `Queue` 에 저장되어야 하는지를 정의한다.

#### Exchange

Exchange 는 RabbitMQ 로 전송된 메시지를 수신하고 메세지를 보낼 위치(큐)를 결정한다.
RabbitMQ 는 위와 같은 라우팅 동작을 처리하는 여러 유형의 Exchange 가 존재한다.
추가로 플러그인을 통해 직접 커스텀 익스체인지를 정의하는 것도 가능하다.

#### Queue

Queue 는 수신한 메시지를 저장한다.
Queue 에는 메시지에 수행하는 작업을 정의하는 정보가 있다. (옵션? 속성?)

Queue 설정정보
- 메모리에만 저장?
- 소비자에게 전달 전 FIFO 순서로 메시지를 디스크에 저장?

#### Binding
Binding 은 Queue 와 Exchange 의 관계를 정의한다.
RabbitMQ 는 `Binding` 과 `Binding-key` 를 통해 Exchange 에 전달된 메시지를 어떤 Queue에 전달할지를 결정하낟.

애플리케이션에서 Exchnage 로 메시지를 보낼 때에는 `Routing-key` 속성을 사용한다.
`Routing-key` 는 기본적으로는 Queue 의 이름이다.
Exchange 의 유형에 따라 `Routing-key` 를 큐의 이름으로 사용할지, 패턴에 매칭시킬지, 속성을 우선적으로 판단할지가 결정된다.


---

## ch2

### RPC 전송으로서의 AMQP

```
RPC
한 컴퓨터에서 다른 컴퓨터의 프로그램이나 메서드를 원격에서 실행할 수 있게 해주는 컴퓨터 간 통신 유형 중 하나이다.
API 를 통하는 웹 또한 RPC 패턴 중 하나로 볼 수 있다.
```

RabbitMQ 와 통신 시 발생하는 RPC 는 웹 기반 API 와는 다른 부분이 많다.
웹 API 의 경우 클라이언트가 명령을 실행하고 서버가 응답을 보내는 구조이다.
서버가 클라이언트로 명령을 다시 보내지는 않는다. (클라이언트 -> 서버 API)

반면 AMQP 스펙의 경우 서버와 클라이언트 모두 명령을 실행할 수 있다.
클라이언트 측도 서버로부터 메시지를 받을 수 있도록 큐 서버를 구독하고 있어야 한다.

### 올바른 채널로 튜닝
양방향 라디오와 유사하게 AMQP 스펙에는 RabbitMQ 와 통신하기 위한 `채널`이 존재한다.
채널은 연결협상이 완료된 AMQP 연결을 정보전송을 위한 `수도관`으로 사용된다.
이 정보전송을 위한 `수도관(채널)` 은 다른 채널으로부터 격리된다.
단일 AMQP 연결에는 여러 채널이 존재하므로 여러 메시지 대화를 수행할 수 있다. 이를 `멀티플렉싱` 이라 한다.

```
RabbitMQ 사용시 너무 많은 채널을 사용하는 것은 좋지 않다.
RabbitMQ 서버와 클라이언트에서 채널은 많은 리소스를 차지않다. 각 채널마다 메모리 구조와 객체가 설정되기 때문이다.
채널이 많을수록 RabbitMQ 는 이를 관리하는데 더 많은 메모리를 사용해야 한다.
적당한? 채널을 유지하는 것이 좋다.
```

### AMQP의 RPC 프레임 구조
AMQP 스펙은 객체지향에서의 개념과 비슷한 `클래스` 와 `메서드`를 사용하여 `AMQP 명령어`를 정의한다.
각 클래스에는 각 작업을 위한 AMQP 메서드가 존재한다.
연결협상 과정에서 연결협상 과정에서 `Connection.Start` 명령어를 클라이언트로 전송한다.
여기서 `Connection` 은 클래스에 `Start` 는 메서드에 해당한다.

### AMQP 프레임?
RabbitMQ 에서 AMQP 명령어를 전송하거나 수신할 때 필요한 모든 인자들은 `프레임`으로 인코딩되서 전송된다.
프레임은 명령과 인자를 인코딩해서 각 프레임이 서로 구분되도록 하는 효율적인 방법이다.

`프레임`은 `열차의 한 칸`과 유사하다.
열차 한 칸은 `서로 동일한 기본 구조`로 되어있고 `내용으로 서로 구분`된다.

AMQP 프레임은 5개 요소로 구성된다.
- 프레임 유형
- 채널 번호
- 프레임 크기(byte)
- 프레임 페이로드
- 끝 바이트 표시

AMQP 프레임의 헤더는 세 개 필드로 구성된다.
- 프레임 헤더
  - 프레임 유형: 단일 바이드
  - 채널 번호: 프레임이 속하는 채널을 지정
  - 프레임 크기: 프레임 본문의 크기

### 프레임 유형

- 프로토콜 헤더 프레임
  - RabbitMQ 연결시 한 번만 사용된다.
- 메서드 프레임
  - RabbitMQ 와 서로 주고받는 RPC 요청이나 응답을 전송한다.
- 콘텐츠 헤더 프레임
  - `메시지의 크기`와 속성을 포함한다.
- 바디 프레임
  - `메시지의 내용`을 포함한다.
- 하트비트 프레임
  - RabbitMQ 와 연결된 클라이언트와 서버가 주고받으면서 서로 사용 가능한 상태인지 확인한다.

```
하트비트
RabbitMQ 는 클라이언트에 하트비트를 보내고 응답이 오지 않는다면 클라이언트와 연결을 끊는다.
보통 비동기 환경에서는 큰 값을 설정한다. (보통 비동기를 위해 사용하니 그냥 큰 값을.)

하트비트 간격을 0으로 설정하는 하트비트를 끌 수 있다.
```

### 메시지 프레임 마샬링
RabbitMQ 에서 메시지 발생시 메서드 프레임, 헤더 프레임, 바디 프레임이 사용된다.

첫 번째 전송되는 프레임은 `메서드 프레임` 이다.
`메서드 프레임` 은 익스체인지와 라우팅키를 포함한다.

다음으로 내용에 해당하는 `콘텐츠 헤더 프레임`과 `바디 프레임`이 전송된다.
`콘텐츠 헤더 프레임` 에는 본문의 크기와 메시지의 속성이 포함된다.

AMQP 는 최대 프레임 크기가 있고 이를 초과하는 경우 본문이 여러 `바디 프레임` 으로 분할된다.

메서드 프레임 -> 콘텐츠 헤더 프레임 -> 바디 프레임(하나 이상의)

효율적인 전송을 위해 메서드 프레임과 콘텐츠 헤더 프레임은 이진 데이터로 구성된다.
바디 프레임의 경우 압축이나 인코딩 되지 않은 데이터로 구성되고 일반 텍스트부터 이진 이미지 데이터까지 저장가능하다.

### 메서드 프레임
메서드 프레임 => RPC 요청을 처리할 클래스, 메서드, 인수(익스체인지, 라우팅 키)

메서드 프레임의 마지막은 `mandatory` 플래그이다.
이 플래그는 RabbitMQ가 메시지를 라우팅할 수 있는지 할 수 없는지를 알려준다.
라우팅 할 수 없는 경우 `Basic.Return` 프레임을 반환한다.

### 정상적인 에러 처리
RabbitMQ 에서 에러 발생시 에러 코드를 반환하고 채널을 닫는다.
ex) 같은 이름의 속성이 다른 큐를 정의하려는 경우 해당 RPC 명령을 보낸 채널을 닫는다.
ex) 가상호스트에 접근권한이 없는 사용자가 큐를 생성하려는 경우 403 에러를 반환하고 채널을 닫는다.

클라이언트 측에서 에러를 처리하려면 RabbitMQ 로부터 `Channel.Close` 를 받아 적절하게 응답해야 한다.
서버에서 전송한 에러에 대한 응답을 수신하지 않거나 적절하게 처리하지 않으면 `메시지가 손실`될 수 있다.

RabbitMQ 는 이미 닫힌 채널에 메시지를 발행하는 경우 알아서 연결을 종료한다.


### 존재하지 않는 익스체인지에 메시지를 발행하는 경우
기본적으로 메시지는 버려진다.
메시지가 익스체인지에 제대로 발행됐는지 확인하려면 메시지 발생시 `메서드 프레임` 의 `mandatory` 플래그를 `true`로 설정하거나 `발행자 확인` 을 사용해야 한다. (but, 메시지 발행 속도가 저하될 수 있다.)


### 메시지 발행
1. 메서드 프레임에 포함된 익스체인지 이름과 일치하는 익스체인지를 찾는다.
2. 익스체인지 내부에 바인딩을 평가하며 메서드 프레임이 포함된 라우팅 키와 일치하는 큐를 찾는다.
3. 일치하는 큐를 찾으면 선입선출로 메시지를 큐에 삽입한다.

큐에 실제 메시지를 넣는 것은 아니고 메시지에 대한 `참조`가 큐에 삽입된다.

메시지의 참조본? 사본? 이 모두 소비되는 경우 RabbitMQ 는 메시지를 메모리에서 제거한다.


---

## ch3
메시지 속성 심층 탐사
- 메세지 속성, 속성이 메시지 전송에 미치는 영향

### 메시지 속성 적절히 사용하기

메시지는 세 가지 프레임으로 구성된다.
- Basic.Publish 메서드 프레임
- 콘텐츠 헤더 프레임
- 바디 프레임

콘텐츠 헤더 프레임은 `Basic.Properties` 를 포함한다.
`Basic.Properties` 에는 `delivery-mode` 와 같이 AMQP 스펙에 사전에 정의된 속성도 있지만 `type`과 같이 정확한 스펙이 없는 속성도 존재한다.

`delivery-mode`
메시지가 큐에 있을 때 메시지를 메모리에 보관할지, 디스크에 먼저 저장할지에 대한 설정이다.

```
메시지을 사용해서 메시지를 설명하는 것은 유용하지만 소비자 애플리케이션에서 메시지의 속성을 사용할 수 있는지 확인해야 한다. RabbitMQ 에서 MQTT 프로토콜을 사용하는 경우 AMQP 스펙에 정의된 특정 속성은 사용할 수 없게 된다.
```

#### AMQP 메시지 속성
- `content-type`: 메시지 본문 해석 방법
- `content-encoding`
- `message-id`, `correlation-id`: 메시지의 고유 식별값
- `timestamp`: 메시지의 크기를 줄인다??, 메시지 생성 시점의 표준시간
- `expiration`: 메시지 만료
- `delivery-mode`: 큐에 메시지 추가시 디스크에 저장할지, 메모리에 저장할지
- `app-id`, `user-id`: 발행자 애플리케이션 식별
- `type`: 발행자와 소비자 사이 계약을 정의
- `reply-to`: 패턴 값으로 응답 메시지를 라우팅
- `headers`: RabbitMQ 에 메시지 라우팅 시 커스텀 한 속성 전달

#### gzip, content-encoding 으로 메시지 크기 줄이기
AMQP 를 이용해서 전달되는 메시지는 기본적으로는 압축되지 않는다.
그렇기 때문에 너무 큰 메시지가 전달되거나 XML과 같은 지나치게 자세한 포맷으로 메시지가 전달되는 경우 문제가 될 수 있다.

서버에서 웹페이지를 `gzip` 으로 압축하고 브라우저에서 랜드링 전 압축을 푸는 것과 비슷하게 발행하는 메시지를 발행하기 전 메시지를 압축하고 소비자가 압축을 풀도록 할 수 있다.
위와 같은 처리를 `content-encoding` 속성으로 처리한다.
메시지 본문이 `base64` or `gzip` ... 과 같은 형식으로 인코딩 됐는지 알 수 있다.

```
content-encoding <-> content-type

HTTP 스펙과 마찬가지로 AMQP 에서도 content-encoding 은 content-type 을 넘어선 인코딩 수준을 나타낸다.
본문이 gzip 또는 다른 형식으로 압축됐음을 나타낸다.

일부 AMQP 클라이언트에서 content-encoding 을 UTF-8 로 기본설정하는데 이는 잘못된 것이다.
AMQP 스펙은 content-encoding 이 MIME 콘텐츠 인코딩을 저장하기 위함이라고 명시돼 있다.
```

SMTP의 경우 주로 Base64 형태로 본문을 인코딩 한다. 
이미지가 포함된 HTML 을 만드는 경우 이미지를 포함한 모든 본문을 Base64로 인코딩하게 된다.
이 때 인코딩 된 데이터는 SMTP 프로토콜의 범위를 넘기지 않아야 한다.

AMQP 는 SMTP 와 달리 바이너리 프로토콜이다.
메시지 본문은 그대로 전달되고 마샬링, 언마샬링 과정에서 인코딩되거나 변환되지 않는다.
모든 메시지는 프로토콜 위반 걱정 없이 다양한 형식으로 전달될 수 있다.

```
MIME (Multipurpose Internet Mail Extensions)
이메일과 함께 동봉할 파일을 텍스트 문자로 전환해서 이메일 시스템을 통해 전달하기 위해 사용된다.
본래 목적은 위와 같지만 현재에는 웹 상에서 여러 형태의 파일 전달시 사용되고 있다.

바이너리 파일(이미지, 음악, 영상...) 전송시 바이너리를 텍스트로 변환하는 과정을 인코딩이라 하고 그 반대를 디코딩이라 한다.

MIME으로 인코딩 된 파일은 Content-type 에 인코딩에 대한 정보가 담겨진다.
```

```
SMTP (Simple Mail Transfer Protocol 25)
메일 전송시 사용되는 표준 프로토콜이다. (수신 프로토콜로는 POP3, IMAP 등이 있다.)
메일을 보내는 클라이언트는 SMTP 와 TCP 연결을 맺고 메일을 전송한다.
이런 연결지향형 프로토콜이기 때문에 SMTP 서버는 항상 연결을 위해 수신 대기한다.

```

content-type 과 content-encoding 속성을 통해 발행자와 소비자는 더 명확한 계약을 맺을 수 있다.
발행자 쪽에서 더 효율적인 방식으로 메시지 압축 방식을 바꿔야 하는 경우 content-encoding 도 함께 바뀔 것이다.
소비자 쪽에서는 content-encoding 을 검사하고 디코딩 할 수 없다면 메시지를 거부하는 방식으로 안전하게 처리할 수 있다.


#### message-id 와 correlation-id 를 이용한 메시지 참조
AMQP 스펙에서 `message-id` 와 `correlation-id`는 애플리케이션 용도로 지정하고 특별히 정의된 동작은 없다.
애플리케이션에서 원하는 용도로 사용할 수 있다.
두 필드는 255바이트의 UTF-8로 인코딩 된 값을 가진다.

message-id 는 메시지의 식별 값이다.

correlation-id 는 공식적인 정의는 없다.
좋은 사용 예로는 현재 메시지와 관련된 메시지의 message-id 를 correlation-id 로 지정해서 다른 메시지에 대한 응답 또는 관련됨을 표시할 수 있다.


#### expiration - 자동으로 메시지 만료하기
expiration 은 소비되지 않은 메시지를 버려야 할 때를 알려준다.
유닉스 시간으로 설정하며 문자열 형태로 저장되야 한다.
expiration 이 설정된 메시지가 RabbitMQ 에 도착하고 시간이 만료된 경우 메시지는 큐로 삽입되지 않고 삭제된다.

RabbitMQ 는 메시지가 아닌 큐에 만료시간을 지정할 수도 있다. `x-message-ttl`
위 속성이 설정된 큐에 메시지가 전달된 경우 ttl 이 만료되면 큐는 메시지를 버린다.


#### delivery-mode
delivery-mode 는 메시지를 소비자에게 전달하기 전에 디스크에 저장할지 여부를 결정한다. (디스크에 저장 O = 2, 디스크에 저장 X =1)
메시지를 디스크에 저장하는 경우 RabbitMQ 서버가 재시작되더라도 메시지가 소비될 때까지 큐에 남게 된다.

```
메시지 Persistence, 큐 Durable 의 차이

큐의 durable 속성: RabbitMQ 서버나 클러스터를 재시작한 후에도 큐에 대한 정의가 유지돼야 하는 지에 대한 설정이다.
메시지 Persistence (delivery-mode): 하나의 큐는 지속성 메시지(delivery-mode=2)와 비지속성 메시지(delivery-mode=1) 를 모두 포함할 수 있다.

??? - 큐는 durable false, 메시지는 비지속성이라면 ?? 
```

근본적으로 메모리 I/O 는 디스크 I/O 보다 빠르기 때문에 `delivery-mode` 를 1로 지정하는 것이 더 빠르게 메시지를 처리할 수 있다.

---

## ch4
메세지 발행에서 성능 절충
- 메시지 배달 보장
- 메시지 배달 보장과 성능의 절충점

#### 발행 속도와 배달 보장의 균형
RabbitMQ 서버가 재부팅됐을 때 메시지가 유지되도록 하는 등의 기능은 속도를 저하시킬 수 있다.
반대로 메시지를 유지시키는 등의 메시지 배달 보장 기능이 없다면 속도는 빠르지만 메시지 손실이 치명적인 시스템이라면 적합하지 않을 것이다.

속도와 안정성을 비교할 때 아래와 같은 질문을 고려해보자.
- 메시지가 큐에 도달하는 것이 얼마나 중요한가
- 메세지를 라우팅할 수 없는 경우, 발행자에게 알려야 하는가
- 메시지를 라우팅할 수 없는 경우, 다른 처리를 위해 다른 곳으로 메시지를 라우팅해야 하는가
- RabbitMQ 서버 장애시 메시지가 손실돼도 괜찮은가
- RabbitMQ 가 모든 메시지를 라우팅한 후에 디스크에 저장하는 작업을 끝마치고 발행자에게 알려야 하는가
...

#### mandatory 플래그를 설정한 메시지를 라우팅할 수 없을 때
메시지에 대한 배달 보장을 하려면 `mandatory` 플래그를 설정할 수 있다.
mandatory 플래그는 메시지를 라우팅 할 수 없을 때 `Basic.Return RPC` 를 통해 발행자에게 메시지를 다시 보내도록 지시한다.
mandatory 플래그를 설정한 경우 메시지가 정상적으로 라우팅 됐다면 발행자에게 별도의 메시지를 보내지 않는다.

`mandatory=true` == `오류 감지 모드 on`

#### 트랜잭션보다 가벼운 발행자 확인
RabbitMQ 의 `발행자 확인` 은 AMPQ 스펙의 확장 기능으로 RabbitMQ 관련 확장을 지원하는 클라이언트 라이브러리에서만 지원한다.
`publisherConfirms enable`

디스크에 메시지를 저장하는 것으로 메시지 손신을 막을 수 있지만 발행자와 RabbitMQ 사이에 메시지가 전달됐음을 확신할 수는 없다.
발행자는 메시지 발행 전 RabbitMQ 에 `Confirm.Select RPC` 요청을 전송하고 메시지가 전달됐는지 확인을 위해 `Confirm.SelectOK` 응답을 기다린다.

1. 발행자: 메시지 발행 전 RabbitMQ 서버에 `Confirm.Select` 전송
2. RabbitMQ: Confirm.SelectOK 응답
3. 발행자: 메시지 발행
4. RabbitMQ: `Basic.Ack` or `Basic.Nack`
5. 발행자: `Basic.Nack` 받은 경우 메시지 재발행 (or 적절한 예외 처리)

`Basic.Ack` 는 발행된 메시지가 소비자에 의해 모두 소비되거나 메시지를 큐의 디스크에 저장한 경우 발행자에게 전송된다.

```
발행자 확인 사용여부와 관계없이 존재하지 않은 익스체인지로 메시지 발행시 RabbitMQ 는 해당 채널을 종료하고 예외 응답을 보낸다.
```

#### 라우팅할 수 없는 메시지를 위항 대체 익스체인지 사용하기
`대체 익스체인지` 는 라우팅할 수 없는 메시지를 처리하기 위해 존재하는 RabbitMQ가 AMQP 를 확장한 기능 중 하나이다.

```
대체 익스체인지 설정은 mandatory 플래그를 설정한 메시지에도 적용된다.
```

대체 익스체인지 사용
1. 대체 익스체인지 생성
2. 기본 익스체인지 생성시 `alternate-exchange` 에 대체 익스체인지 지정


#### 트랜잭션으로 배치 처리하기
RabbitMQ 의 확장스펙인 `발행자 확인` 이전 메시지 전달을 보장할 수 있는 유일한 방법은 `트랜잭션`이었다.
`AMQP 트랜잭션` 은 메시지를 RabbitMQ 에 일괄 발행한 후 큐에 커밋하거나 롤백할 수 있는 기능을 제공한다.

1. 발행자: TX.select 전송
2. RabbitMQ: TX.SelectOK 응답 - `트랜잭션 시작`
3. 발행자: 메시지 발행
4. RabbitMQ: Basic.Return 응답
5. 발행자: Tx.Commit - `메시지 커밋`
6. RabbitMQ: Tx.CommitOK

트랜잭션은 발행자가 RabbitMQ 메시지 브로커의 큐에 메시지를 성공적으로 전달했음을 알리는데 사용된다.
발행자와 RabbitMQ 간 일련의 요청-응답으로 트랜잭션이 열렸다면 발행자는 한 개 이상의 메시지를 보낼 수 있다.

트랜잭션 중에 존재하지 않는 익스체인지와 같은 오류로 인해 RabbitMQ가 메시지를 라우팅할 수 없다면 `CommitOK` 를 응답하기 전에 `Basic.Return` 응답을 반환한다.

```
RabbitMQ 에서 원자 트랜잭션은 트랜잭션의 모든 작업이 완료될 때까지 클라이언트가 TX.CommitOK 응답을 받지 않는 것을 의미한다.
트랜잭션이 한 개 큐에만 메시지를 전달하는 경우 트랜잭션의 원자성은 보장된다.

두 개 이상의 큐에 영향을 끼치는 경우 트랜잭션 커밋의 원자성은 보장되지 않는다.
트랜잭션 내 모든 명령의 대상이 동일한 큐인 경우에만 원자 트랜잭션이 가능한 것이다.

delivery-mode가 2로 설정된 메시지가 원자 트랜잭션으로 동작한다면 성능상 문제가 될 수 있다.
```

메시지가 정상적으로 발행됏는지 확인하는 것이 주요 목적이라면 트랜잭션보다는 조금 더 단순하고 가벼운 `발행자 확인` 을 사용하자.

#### HA 큐를 사용해 노드 장애 대응하기
메세지가 큐애 있는 동안 손실되지 않는 것이 중요한 경우 `HA큐` 를 사용할 수 있다.
(HA큐도 AMQP 스펙이 아닌 확장기능이다.)

HA큐는 큐를 여러 서버에 중복해 복사본을 저장하는 기능을 제공한다.
HA큐는 클러스터로 구성된 RabbitMQ 환경을 필요로 한다.

메시지가 HA큐로 설정된 큐로 발행되면 클러스터링 된 각 서버의 큐로 메시지가 전송된다.
클러스터의 한 노드에서 메시지가 소비되면 다른 노드의 모든 메시지 복사본은 제거된다.

HA 큐에는 단일 `기본노드`가 지정된다. 그 외 다른 모든 노드는 `보조노드`이다.
- 기본노드가 실패하면 보조노드 중 하나가 기본노드의 역할을 한다.
- 보조노드가 다운된 경우 관계없이 다른 노드들은 메시지를 공유한다.
- 다운된 노드가 다시 추가되거나 새 노드가 추가되는 경우 기존 큐잉된 메시지는 포함되지 않는다.
  이전에 발행된 메시지가 모두 소비되고 새로운 메시지가 수신된다면 동기화된다.

HA 큐에서 발행자 확인 or 트랜잭션을 사용하는 경우 클러스터링 된 모든 노드를 확인할 때까지 성공응답을 보내지 않는다.
따라서 응답이 지연될 수 있다.

#### delivery-mode 2 : 메시지 디스크에 저장하기
이미 전달된 메시지가 소비되기 전에 RabbitMQ 서버가 다운된다면 메시지는 유실된다.
서버 재시작시 메시지가 유실되는 것을 막으려면 delivery-mode 의 기본값 1이 아닌 2로 설정해야 한다.

`delivery-mode 2` 의 경우 디스크 I/O 가 발생하면서 성능저하가 발생한다.

고성능 메시지 처리를 위해 RabbitMQ는 메시지를 디스크에 기록하고 더 이상 큐에 해당 메시지가 대기하지 않을 때까지 참조로 메시지를 추적한다.
메시지에 대한 모든 참조가 사라지면 디스크에서 메시지를 제거한다.

- `delivery-mode 2` 메시지는 디스크에 저장된다.
- 큐는 디스크에 저장된 메시지의 참조(포인터) 를 저장한다.

#### RabbitMQ 푸시백
발행자 애플리케이션이 너무 빨리 메시지를 발행하는 경우 RabbitMQ 를 압도할 수 있다.
이런 경우 발행자에게 `Channel.Flow.RPC` 를 보내 차단하고 `Channel.Flow` 를 받을 때까지 더이상 메시지를 보내지 않도록 발행자에게 지시할 수 있다.

위와 같은 방식은 `Channel.Flow` 를 잘못 처리하는 경우 메시지 발행을 늦추는 상당히 비효율적인 방법으로 알려졌다.
RabbitMQ 3.2 이전에 `Channel.Flow` 의 사용을 중단했고 이를 `TCP 배압` 으로 대체했다.

RabbitMQ 는 발행자에게 메시지를 그만 보내도록 정중하게 요청하지 않는다.
TCP 소켓으로 데이터 수신을 중지한다.

내부적으로 RabbitMQ 는 `크레딧`이라는 개념을 사용해서 발행자에 대해 언제 푸시백을 관리할 것인지를 관리한다.
- 새로운 연결이 생성되면 이 연결에서 사용할 크레딧이 할당된다. 
- RabbitMQ가 명령을 수신할 때마다 크레딧은 감소한다.
- 처리가 완료되면 내부적으로 크레딧은 감소분은 되돌려진다.
- 크레딧이 없는 경우 명령은 무시된다.

RabbitMQ 3.2 부터 크레딧에 대한 임계값에 도달했을 때 알림을 추가하고 클라이언트에게 연결이 차단됐다는 사실을 알릴 수 있다.
(`Connection.Blocked`, `Connection.Unblocked`)
