## ch5
메시지를 받지 않고 소비하기

메시지를 소비하는 방법
- 메시지를 단순히 가져올 것인지
- 메시지를 소비해야 하는 것인지

- 단순히 메시지를 전달받지 않고 소비하는 것이 좋은 이유
- 메시지 배달 보장과 성능 간 균형을 유지하는 방법
- RabbitMQ 큐별 설정을 통해 큐를 자동으로 삭제하고, 메시지 수명을 제한하는 등의 작업


#### Basic.Get
`Basic.Get` 은 좋은 방법이 아니다.
`Basic.Get` 은 폴링 모델을 사용한다.

큐에 메시지가 여러 개인 경우에도 메시지를 받을 떼마다 새로운 요청을 보내야 한다.

Basic.Consume 을 사용하는 것이 훨씬 빠르다

#### Basic.Consume
`Basic.Get` 의 동기방식 대신 `Basic.Consume` 을 사용하면 `Basic.Cancel` 을 전송하기 전까지 `pub-sub` 구조로 클라이언트는 RabbitMQ 가 보내는 메시지를 자동으로 수신할 수 있다.

#### 소비자 태그
애플리케이션에서 `Basic.Consume` 을 사용하면 RabbitMQ 채널에서 애플리케이션을 식별하는 고유 문자열이 생성된다.
이를 `소비자 태그` 라고 하고 소비자 태그는 각 메시지와 함께 애플리케이션으로 전송된다.
소비자 태그는 `Basic.Cancel` 명령으로 메시지 수신을 취소할 때 사용할 수 있다.

소비자 애플리케이션이 동시에 여러 큐에서 메시지를 수신하는 경우 메서드 프레임에 포함되는 소비자 태그를 통해 어떤 큐와의 연결인지를 식별할 수 있다.

#### 소비자 성능 조정
메시지 발행과 마찬가지로 소비 시에도 메시지 처리량과 보장(안정성)의 균형을 잡아야 한다.
RabbitMQ 에서 애플리케이션으로 메시지를 전달하는데 사용할 수 있는 몇 가지 옵션이 있다.

- 메시지 수신 확인 응답 (QoS>1 로 메시지 소비)
- 무응답 모드로 메시지 소비
- 수신 확인으로 메시지 소비
- 트랜잭션을 사용해서 메시지 소비
- 메시지 받기

#### 빠른 성능을 우한 무응답 모드 메시지 소비 (메시지 수신 확인 off)
메시지 소비시 애플리케이션은 `Basic.Consume RPC` 로 자신을 RabbitMQ에 등록한다.
`Basic.Consume RPC` 에는 `no-ack` 플래그가 있다.

`no-ack` 활성화 (no_ack=true)
- RabbitMQ는 소비자가 메시지를 수신했는지 확인하지 않는다. 
- RabbitMQ는 부가적인 처리없이 가장 빠르게 메시지를 소비자에게 전송한다.
- 이 방법은 소비자에게 메시지를 보내는 가장 빠른 방법이고 가장 안정적인 방법이기도 하다.

RabbitMQ 는 TCP 소켓 연결을 통해 클라이언트와 통신한다.
이 소켓연결이 열려있고 쓰기 가능한 경우 RabbitMQ 는 모든 것이 정상이라고 간주한다.

RabbitMQ가 메시지를 보내기 위해 TCP 연결소켓에 쓰기작업을 하려할 때 네트워크 문제가 발생하면 OS는 RabbitMQ로 소켓 오류를 발생시킨다.
소켓오류가 발생하지 않는다면 RabbitMQ 는 메시지가 정상적으로 전달됐다고 가정한다.

메시지 수신 확인을 끄면 RabbitMQ 는 소비자의 수신 확인을 기다리지 않고 가능한 경우 다른 메시지를 전송한다.
TCP 소켓 버퍼가 차기 전까지 가능한 경우 메시지를 소비자에게 계속 전송한다.

#### QoS 설정을 통한 소비자 prefetch 제어
AMQP 스펙에는 `소비자가 메시지 수신을 확인하기 전`에 `미리 지정된 수의 메시지를 수신`하도록 처리할 수 있는 `QoS 설정을 채널에 요청`할 수 있다.

QoS 설정을 통해 RabbitMQ는 소비자에게 미리 할당할 메시지 수를 지정해 메시지를 좀 더 효율적으로 보낼 수 있다.

QoS 설정은 해당 채널에만 설정할 수도 있고 연결된 모든 채널에 대해 QoS 를 지정하는 것도 가능하다.

```
AMQP 스펙은 프리페치 수와 프리패치 크기를 모두 설정할 수 있다.
no-ack 옵션을 true 로 설저앟면 프리패치 크기는 무시된다.
```

#### 프리패치 값을 최적의 수준으로 교정
프리패치 수가 지나치게 크면 메시지 처리량에 악영향을 끼칠 수 있다.

동일한 큐에 연결된 다수의 소비나는 라운드 로빈 방식으로 메시지를 수신한다.

```
prefetch?

springboot 의 기본설정을 사용하고 있다면 consumer 는 메시지를 받을 때마다 mq를 통하지 않는다.
prefetch default: 250

consume 대상 메시지를 consumer 측의 메모리에 올려놓는다.

모든 메시지에 대해 매번 mq 를 통하지 않는 것은 성능상 효과적이겠지만 특정 상황에서 성능 저하 포인트가 될 수 있다.

n 개 consumer 가 concurrency 하게 메시지를 받아 처리하고 있다고 가정.
prefetch 에 의해 n개 메시지를 모두 consumer 측의 메모리에 적재 후 작업이 이루어 짐
prefetch 에 의해 모든 메시지가 이미 메모리에 올라가버렸다면 이후 consumer 를 추가한다고 해도 추가 된 consumer 는 메시지를 받아 처리할 수 없다.

why?
consumer 는 ready 상태의 메시지를 받아오는데 prefetch 에 의해 모두 ready 상태의 메시지를 메모리에 올렸기 때문.
consumer 를 추가해도 예상한 효과를 볼 수 없는 것
prefetch 값을 조정해서 새로운 consumer 를 추가하는 상황에도 예상한 만큼의 성능이 나오도록 해보자.

global 설정 (yml)
spring.batch.listener.simple.prefetch=1 (default: 250)

++
prefetch 설정 팁
consumer 의 작업시간이 오래 걸린다면 prefetch 값은 적게 설정하자.
consumer 의 작업시간이 오래 걸린다면 미리 메모리에 메시지를 잔뜩 올려놓을 필요가 있을까?
```

#### 한 번에 여러 메시지 확인하기
QoS 설정 중 유용한 또 다른 점은 `Basic.Ack RPC` 응답과 함께 받은 각 메시지를 개별적으로 하나씩 확인하지 않아도 된다는 것이다.

`Basic.Ack RPC` 응답의 `multiple` 속성을 True 로 설정하고 반환하면 RabbitMQ 는 수신확인하지 않은 모든 메시지를 수신확인으로 처리한다.
`mutiple` 속성을 통해 여러 메시지를 동시에 확인하면 메시지 처리에 필요한 네트워크 통신을 최소화할 수 있다.

일부 메시지를 성공적으로 처리하던 중에 소비자 측에 장애가 발생한다면 모든 미확인 메시지는 다시 큐로 돌아간다.


#### 소비자 애플리케이션에서 트랜잭션 사용하기
메시지를 발행할 때와 마찬가지로 소비자도 일련의 작업을 커밋하고 롤백할 수 있다.

트랜잭션은 한 가지 예외적인 상황을 제외하고서는 메시지 처리량에 부정적인 영향을 끼친다.
QoS 설정을 사용하지 않는 경우에 트랜잭션을 사용해서 메시지 확인 응답을 일괄처리한다면 약간의 성능향상은 볼 수 있다.


#### 메시지 거부하기
메시지 수신 확인은 큐의 메시지를 처리하고 제거하기 전에 소비자가 메시지를 잘 받았는지 확인할 수 있는 좋은 방법이다.

하지만 메시지를 처리하는 중에 문제가 발생한다면?

RabbitMQ 는 메시지를 다시 메시지 브로커에게 전달하는 `Basic.Reject`, `Basic.Nack` 두 가지 메커니즘을 제공한다.

```
Basic.Nack 은 한 번에 여러 메시지를 거부할 수 있다.

Basic.Reject 는 한 번에 하나의 메시지만 거부할 수 있다.
```

#### Basic.Reject
`Basic.Reject` 는 전달받은 메시지를 처리할 수 없음을 메시지 브로커에게 알리는 AMQP 의 RPC 응답이다.

소비자가 메시지를 거부하면 RabbitMQ가 메시지를 삭제하거나 큐에 메시지를 재삽입하도록 지시할 수 있다.
재삽입 `requeue` 플래그가 활성화되면 큐에 메시지를 다시 넣는다.
`requeue` 플래그는 DB나 원격API와 같은 다른 서비스와 통신하는 소비자 애플리케이션 작성시 종종 사용된다.

DB와의 연결이 끊어지거나 원격 API 호출에 실패하는 경우와 같이 원격지의 예외의 경우 소비자 애플리케이션이 재시도 로직을 직접 구현하는 대신, 예외를 잡아서 재삽입 플래그를 활성화 한 메시지를 거부해서 처리한다.

#### Basic.Nack
`Basic.Reject` 는 단일 메시지 거부에 사용된다.
`Basic.Nack` 는 다중 메시지를 거부할 수 있는 RabbitMQ 의 확장기능이다.


#### Dead-Letter Exchange (DLX)
DLX 는 RabbitMQ의 확장기능으로 메시지를 거부할 수 있는 추가적인 기능이다.

DLX 는 Exchange 이고 DLX 를 지정한 `x-dead-letter-exchange` 큐의 소비자가 예외 등으로 메시지를 거부했다면 DLX 로 메시지가 전달된다.

```
DLX 는 대체 익스체인지와는 다르다.
DLX 로는 만료되거나 거절된 메시지가 전달되는 반면 대채 익스체인지는 RabbitMQ 가 라우팅할 수 없는 메시지가 전달된다.
```

DLX 를 지정하는 것 말고 라우팅 키를 미리 지정된 값으로 대체할 수도 있다.
거부된 메시지는 미리 지정된 라우팅 키를 타고 지정된 큐로 전달될 수 있다.
(`x-dead-letter-routing-key` 지정)

```
RabbitMQ 의 모든 큐는 선언 후 변경될 수 없다.
이미 선언된 큐에 DLX 를 설정하는 것은 불가능하다. 큐를 삭제하고 재 선언해야 한다.
```


#### 큐 제어하기
소비자의 특징에 따라 여러 종류의 큐가 사용될 수 있다.
- 자동 삭제 큐
- 큐 독점 설정
- 자동 메시지 만료
- 대기 메시지 수 제한
- 오래된 메시지 큐에서 제거


#### 자동삭제 큐
사용 후 삭제되는 큐이다.
`자동삭제 큐`가 만들어지고 메시지가 발행되고 소비자에게 메시지가 전달되고 연결이 끊으면 큐는 제거된다.
`auto_delete` 플래그로 자동삭제 큐를 생성할 수 있다.

큐에는 여러 명의 소비자가 있을 수 있다.
자동삭제 큐는 더 이상 소비자가 없을 경우에 자신을 삭제한다.

#### 큐 독점 설정
기본적으로 큐를 소비하는 소비자의 수는 제한이 없다.
모든 소비자에게 라운드 로빈으로 메시지를 전달한다.

단일 소비자에 의해 독점점으로 큐의 메시지가 소비되도록 하려면 `exclusive` 로 설정된 큐를 생성하자.

독점 큐는 채널이 닫히면 삭제된다.
자동삭제 큐처럼 소비자가 없을 경우 삭제된느 것은 아니다.

#### 자동 만료 큐
일정 기간동안 사용되지 않은 경우 삭제되는 큐이다.
`자동 만료 큐`는 `x-expires` 를 설정함으로 생성할 수 있다.

자동 만료 큐 규칙
- 큐는 연결된 소비자가 없으면 만료된다. 
- TTL (`x-expires`) 동안 `Basic.Get` 요청이 없으면 만료된다. 메시지가 하나 소비되면 TTL 은 초기화된다.
- 큐가 만료될 때 즉시 제거되는 것을 보장하지 않는다 (?)

#### 영구적인 큐
서버 재시작 후에도 유지되는 큐이다.
`durability` 플래그를 설정함으로 생성할 수 있다.

#### 큐에서 메시지 자동만료
메시지를 너무 오랫동안 소비하지 않는 경우 메시지를 삭제하는 큐이다.
`x-message-ttl` 속성을 설정함으로 생성할 수 있디.
메시지마다 적용되는 메시지의 `expiration` 속성과 달리 `x-message-ttl`은 큐의 모든 메시지의 수명을 결정한다.

`x-message-ttl` 과 DLX 를 모두 설정하면 `x-message-ttl` 가 만료한 메시지는 DLX 로 보내진다.

#### 제한된 수의 메시지 보관
메시지의 최대 크기를 지정할 수 있다.
`x-max-length` 를 설정함으로 생성할 수 있다.
메시지가 큐에 계속 쌓이면서 `x-max-length`가 초과되면 FIFO 방식으로 메시지를 삭제한다.

DLX 설정시 FIFO 방식으로 제거된 메시지는 DLX로 보내진다.