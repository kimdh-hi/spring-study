## ch5
메시지를 받지 않고 소비하기

메시지를 소비하는 방법
- 메시지를 단순히 가져올 것인지
- 메시지를 소비해야 하는 것인지

- 단순히 메시지를 전달받지 않고 소비하는 것이 좋은 이유
- 메시지 배달 보장과 성능 간 균형을 유지하는 방법
- RabbitMQ 큐별 설정을 통해 큐를 자동으로 삭제하고, 메시지 수명을 제한하는 등의 작업


#### Basic.Get
`Basic.Get` 은 좋은 방법이 아니다.
`Basic.Get` 은 폴링 모델을 사용한다.

큐에 메시지가 여러 개인 경우에도 메시지를 받을 떼마다 새로운 요청을 보내야 한다.

Basic.Consume 을 사용하는 것이 훨씬 빠르다

#### Basic.Consume
`Basic.Get` 의 동기방식 대신 `Basic.Consume` 을 사용하면 `Basic.Cancel` 을 전송하기 전까지 `pub-sub` 구조로 클라이언트는 RabbitMQ 가 보내는 메시지를 자동으로 수신할 수 있다.

#### 소비자 태그
애플리케이션에서 `Basic.Consume` 을 사용하면 RabbitMQ 채널에서 애플리케이션을 식별하는 고유 문자열이 생성된다.
이를 `소비자 태그` 라고 하고 소비자 태그는 각 메시지와 함께 애플리케이션으로 전송된다.
소비자 태그는 `Basic.Cancel` 명령으로 메시지 수신을 취소할 때 사용할 수 있다.

소비자 애플리케이션이 동시에 여러 큐에서 메시지를 수신하는 경우 메서드 프레임에 포함되는 소비자 태그를 통해 어떤 큐와의 연결인지를 식별할 수 있다.

#### 소비자 성능 조정
메시지 발행과 마찬가지로 소비 시에도 메시지 처리량과 보장(안정성)의 균형을 잡아야 한다.
RabbitMQ 에서 애플리케이션으로 메시지를 전달하는데 사용할 수 있는 몇 가지 옵션이 있다.

- 메시지 수신 확인 응답 (QoS>1 로 메시지 소비)
- 무응답 모드로 메시지 소비
- 수신 확인으로 메시지 소비
- 트랜잭션을 사용해서 메시지 소비
- 메시지 받기

#### 빠른 성능을 우한 무응답 모드 메시지 소비 (메시지 수신 확인 off)
메시지 소비시 애플리케이션은 `Basic.Consume RPC` 로 자신을 RabbitMQ에 등록한다.
`Basic.Consume RPC` 에는 `no-ack` 플래그가 있다.

`no-ack` 활성화 (no_ack=true)
- RabbitMQ는 소비자가 메시지를 수신했는지 확인하지 않는다. 
- RabbitMQ는 부가적인 처리없이 가장 빠르게 메시지를 소비자에게 전송한다.
- 이 방법은 소비자에게 메시지를 보내는 가장 빠른 방법이고 가장 안정적인 방법이기도 하다.

RabbitMQ 는 TCP 소켓 연결을 통해 클라이언트와 통신한다.
이 소켓연결이 열려있고 쓰기 가능한 경우 RabbitMQ 는 모든 것이 정상이라고 간주한다.

RabbitMQ가 메시지를 보내기 위해 TCP 연결소켓에 쓰기작업을 하려할 때 네트워크 문제가 발생하면 OS는 RabbitMQ로 소켓 오류를 발생시킨다.
소켓오류가 발생하지 않는다면 RabbitMQ 는 메시지가 정상적으로 전달됐다고 가정한다.

메시지 수신 확인을 끄면 RabbitMQ 는 소비자의 수신 확인을 기다리지 않고 가능한 경우 다른 메시지를 전송한다.
TCP 소켓 버퍼가 차기 전까지 가능한 경우 메시지를 소비자에게 계속 전송한다.

<!-- 129
#### QoS 설정을 통한 소비자 prefetch 제어
AMQP 스펙에는 `소비자가 메시지 수신을 확인하기 전`에 `미리 지정된 수의 메시지를 수신`하도록 처리할 수 있는 QoS 설정을 채널에 요청할 수 있다.

QoS 설정을 통해 RabbitMQ는 소비자에게 미리 할당할 메시지 수를 지정해 메시지를 좀 더 효율적으로 보낼 수 있다. -->





