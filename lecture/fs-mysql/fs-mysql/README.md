

### MySql Index

자료구조
- `B+Tree` 를 사용한다.
  - `B+Tree`
    - 삽입, 삭제시 추가작업을 통해 트리는 균형을 이룬다.
    - 하나의 노드가 여러 개 자식 노드를 가질 수 있다.
    - 리프노드에만 데이터가 존재한다.
      - MySql 의 경우 리프노드에 존재하는 데이터는 `pk` 이다.
      - Oracle 의 경우 리프노드에 데이터의 주소값이 저장된다.

클러스터드 인덱스 
- 클러스터드 인덱스는 데이터의 위치에 대한 키 값이다.
  - 클러스터드 키의 순서에 따라 데이터 저장 위치가 변경되므로 클러스터드 키의 삽입, 삭제시 성능상 이슈가 발생할 수 있다.
- MySql 에서 모든 PK 는 클러스터드 인덱스이다. (PK == 클러스터드 인덱스)
  - 바꿔말하면 PK 순서에 따라 데이터 저장 위치가 변경되므로 PK 삽입, 삭제시 성능상 이슈가 발생할 수 있다.
  - `PK Auto_increment vs UUID ...`
- MySql 에서 PK 테이블을 제외한 모든 인덱스 테이블은 PK 를 값으로 저장한다.
  - PK 의 크기가 인덱스의 크기를 결정한다.

PK 를 제외한 나머지 인덱스를 지칭하는 세컨더리 인덱스만으로 데이터를 찾아갈 수 없다.
세컨더리 인덱스의 검색결과로 찾아지 것은 결국 PK 이다.
결국 PK 인덱스를 타게 된다.

세컨더리 인덱스는 지정한 인덱스 키값으로 정렬되고 그 값으로는 PK를 저장한다.
인덱스 키값으로 B-Tree 를 순회하며 리프노드에 도달했을 때 결국 찾아지는 값은 PK 인 것이다.

세컨더리 인덱스의 리프노드에서 찾은 PK 로 다시 PK 인덱스 테이블을 순회하며 PK 인덱스 테이블의 리프노드에 도달했을 때 실제 데이터의 주소를 찾게 된다.







