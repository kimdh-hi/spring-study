

### MySql Index

#### 자료구조
- `B+Tree` 를 사용한다.
  - `B+Tree`
    - 삽입, 삭제시 추가작업을 통해 트리는 균형을 이룬다.
    - 하나의 노드가 여러 개 자식 노드를 가질 수 있다.
    - 리프노드에만 데이터가 존재한다.
      - MySql 의 경우 리프노드에 존재하는 데이터는 `pk` 이다.
      - Oracle 의 경우 리프노드에 데이터의 주소값이 저장된다.

#### 클러스터드 인덱스 
- 클러스터드 인덱스는 데이터의 위치에 대한 키 값이다.
  - 클러스터드 키의 순서에 따라 데이터 저장 위치가 변경되므로 클러스터드 키의 삽입, 삭제시 성능상 이슈가 발생할 수 있다.
- MySql 에서 모든 PK 는 클러스터드 인덱스이다. (PK == 클러스터드 인덱스)
  - 바꿔말하면 PK 순서에 따라 데이터 저장 위치가 변경되므로 PK 삽입, 삭제시 성능상 이슈가 발생할 수 있다.
  - `PK Auto_increment vs UUID ...`
- MySql 에서 PK 테이블을 제외한 모든 인덱스 테이블은 PK 를 값으로 저장한다.
  - PK 의 크기가 인덱스의 크기를 결정한다.

PK 를 제외한 나머지 인덱스를 지칭하는 세컨더리 인덱스만으로 데이터를 찾아갈 수 없다.
세컨더리 인덱스의 검색결과로 찾아지 것은 결국 PK 이다.
결국 PK 인덱스를 타게 된다.

세컨더리 인덱스는 지정한 인덱스 키값으로 정렬되고 그 값으로는 PK를 저장한다.
인덱스 키값으로 B-Tree 를 순회하며 리프노드에 도달했을 때 결국 찾아지는 값은 PK 인 것이다.

세컨더리 인덱스의 리프노드에서 찾은 PK 로 다시 PK 인덱스 테이블을 순회하며 PK 인덱스 테이블의 리프노드에 도달했을 때 실제 데이터의 주소를 찾게 된다.


#### 인덱스 적용시 주의

1. 인덱스 대상 필드를 가공할 경우 인덱스를 타지 못한다.

```sql
select *
from member
where age * 10 = 1
```
값은 그대로 인덱스의 키 값으로 사용되기 때문에 가공시 인덱스가 적용되지 않는다.

```sql
select *
from member
where age = '1';
```
인덱스를 사용하기 위해 조건을 걸 때 타입을 맞춰줘야 한다.<br/>
`age` 가 int 타입인 경우 위 쿼리문은 인덱스를 타지 못한다

2. 복합 인덱스

PK 인덱스를 제외한 세컨터리 인덱스들은 값을 `인덱스 키` 로 하고 PK 를 값으로 한다.<br/>
정렬은 `인덱스 키` 로 수행하고 동일한 `인덱스 키` 에 대해서는 PK 를 기준으로 정렬된다.

복합 인덱스는 두 개의 `인덱스 키` 를 갖는다.<br/>
`선두 인덱스 키` 기준으로 먼저 정렬되고 `선두 인덱스 키` 가 동일한 경우 다음 인덱스 키를 기준으로 정렬된다.

`선두 인덱스 키`는 단독으로 인덱스 조건에 사용될 수 있지만 `이후 인덱스 키`는 선두 인덱스 키 없이는 인덱스를 타지 못한다.<br/>
`선두 인덱스 키` 를 기준으로 정렬되고 동률인 경우 `두 번째 인덱스 키` 가 사용되는 것이므로 `두 번째 인덱스 키`로 정렬되지는 않았기 때문이다.

3. 하나의 쿼리는 하나의 인덱스만 탄다.

기본적으로 하나의 쿼리로 여러 인덱스 테이블을 사용하지 않는다.<br/>
(`index merge hint` 를 사용하면 여러 인덱스 테이블을 사용할 수 있다..)

---

### 오프셋 기반 페이지네이션의 문제

1. 마지막 페이지를 알아야 함으로 데이터의 전체건수 (totalElements) 를 알아야 함
`데이터가 많아질수록 전체 데이터 수를 구하는 것은 부담`이다.

일부 대용량 데이터를 다루는 시스템에서 offset 기반 페이징을 지원하는 경우 마지막 페이지에 대한 바로 접근을 막거나 스크롤 형태로 데이터를 제공한다.

2. 불필요 한 데이터 조회
offset 기반으로 데이터를 읽을 때 offset 이전까지 데이터를는 사용하지 않지만 읽어야 한다.
데이터가 많아지고 offset 크기가 커지는 만큼 읽고 사용되지 않는 데이터가 많아진다.

위 문제를 해결하기 위해 `커서 기반 페이징`을 사용한다.

### 커서 기반 페이징

커서 기반 페이징은 offset 이 아닌 key 를 기반으로 데이터를 읽기 시작한다.
key 에 해당하는 데이터부터 size 만큼 읽는 것이다.
offset 처럼 offset 이전까지 데이터를 읽을 필요가 없다.
서버는 데이터를 size만큼 읽고 다음 key를 함께 응답한다.

but, 커서 기반 페이징은 전체 데이터를 조회하지 않으므로 totalElements 를 포함할 수 없다.
즉, 마지막 페이지에 대한 바로 접근 기능을 제공할 수 없다.




