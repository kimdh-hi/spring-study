

### MySql Index

#### 자료구조
- `B+Tree` 를 사용한다.
  - `B+Tree`
    - 삽입, 삭제시 추가작업을 통해 트리는 균형을 이룬다.
    - 하나의 노드가 여러 개 자식 노드를 가질 수 있다.
    - 리프노드에만 데이터가 존재한다.
      - MySql 의 경우 리프노드에 존재하는 데이터는 `pk` 이다.
      - Oracle 의 경우 리프노드에 데이터의 주소값이 저장된다.

#### 클러스터드 인덱스 
- 클러스터드 인덱스는 데이터의 위치에 대한 키 값이다.
  - 클러스터드 키의 순서에 따라 데이터 저장 위치가 변경되므로 클러스터드 키의 삽입, 삭제시 성능상 이슈가 발생할 수 있다.
- MySql 에서 모든 PK 는 클러스터드 인덱스이다. (PK == 클러스터드 인덱스)
  - 바꿔말하면 PK 순서에 따라 데이터 저장 위치가 변경되므로 PK 삽입, 삭제시 성능상 이슈가 발생할 수 있다.
  - `PK Auto_increment vs UUID ...`
- MySql 에서 PK 테이블을 제외한 모든 인덱스 테이블은 PK 를 값으로 저장한다.
  - PK 의 크기가 인덱스의 크기를 결정한다.

PK 를 제외한 나머지 인덱스를 지칭하는 세컨더리 인덱스만으로 데이터를 찾아갈 수 없다.
세컨더리 인덱스의 검색결과로 찾아지 것은 결국 PK 이다.
결국 PK 인덱스를 타게 된다.

세컨더리 인덱스는 지정한 인덱스 키값으로 정렬되고 그 값으로는 PK를 저장한다.
인덱스 키값으로 B-Tree 를 순회하며 리프노드에 도달했을 때 결국 찾아지는 값은 PK 인 것이다.

세컨더리 인덱스의 리프노드에서 찾은 PK 로 다시 PK 인덱스 테이블을 순회하며 PK 인덱스 테이블의 리프노드에 도달했을 때 실제 데이터의 주소를 찾게 된다.


#### 인덱스 적용시 주의

1. 인덱스 대상 필드를 가공할 경우 인덱스를 타지 못한다.

```sql
select *
from member
where age * 10 = 1
```
값은 그대로 인덱스의 키 값으로 사용되기 때문에 가공시 인덱스가 적용되지 않는다.

```sql
select *
from member
where age = '1';
```
인덱스를 사용하기 위해 조건을 걸 때 타입을 맞춰줘야 한다.<br/>
`age` 가 int 타입인 경우 위 쿼리문은 인덱스를 타지 못한다

2. 복합 인덱스

PK 인덱스를 제외한 세컨터리 인덱스들은 값을 `인덱스 키` 로 하고 PK 를 값으로 한다.<br/>
정렬은 `인덱스 키` 로 수행하고 동일한 `인덱스 키` 에 대해서는 PK 를 기준으로 정렬된다.

복합 인덱스는 두 개의 `인덱스 키` 를 갖는다.<br/>
`선두 인덱스 키` 기준으로 먼저 정렬되고 `선두 인덱스 키` 가 동일한 경우 다음 인덱스 키를 기준으로 정렬된다.

`선두 인덱스 키`는 단독으로 인덱스 조건에 사용될 수 있지만 `이후 인덱스 키`는 선두 인덱스 키 없이는 인덱스를 타지 못한다.<br/>
`선두 인덱스 키` 를 기준으로 정렬되고 동률인 경우 `두 번째 인덱스 키` 가 사용되는 것이므로 `두 번째 인덱스 키`로 정렬되지는 않았기 때문이다.

3. 하나의 쿼리는 하나의 인덱스만 탄다.

기본적으로 하나의 쿼리로 여러 인덱스 테이블을 사용하지 않는다.<br/>
(`index merge hint` 를 사용하면 여러 인덱스 테이블을 사용할 수 있다..)